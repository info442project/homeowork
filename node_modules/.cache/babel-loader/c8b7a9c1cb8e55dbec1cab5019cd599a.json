{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React, { PureComponent } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport CSSTransitionGroup from 'react-transition-group/CSSTransitionGroup';\nimport cn from 'classnames';\nimport handleWindowClickListeners from '../utils/EventUtils/handleWindowClickListeners';\nimport getSelectedTextPosition from '../utils/Positioning/getSelectedTextPosition';\nimport getScroll from '../utils/Positioning/getScroll';\nimport viewport from '../utils/Positioning/viewport';\nimport isOutOfBounds from '../utils/Positioning/isOutOfBounds';\nimport anchorShape from './anchorShape';\nimport fixedToShape from './fixedToShape';\nimport positionShape from './positionShape';\nimport HorizontalAnchors from './HorizontalAnchors';\nimport VerticalAnchors from './VerticalAnchors';\nimport Positions from './Positions';\nimport ResizeObserver from './ResizeObserver';\n/**\n * The Layover component is used to keep a component fixed to another component\n * while the page is scrolling or a container is scrolling. When the fixed component\n * is considered out of view, it will be closed.\n *\n * > NOTE: Don't look at source code. Plz.\n */\n\nvar Layover = function (_PureComponent) {\n  _inherits(Layover, _PureComponent);\n\n  function Layover(props) {\n    _classCallCheck(this, Layover);\n\n    var _this = _possibleConstructorReturn(this, _PureComponent.call(this));\n\n    _initialiseProps.call(_this);\n\n    var child = React.Children.only(props.children);\n    _this.state = {\n      below: false,\n      right: false,\n      styles: child.props.style\n    };\n    _this._lastXFix = null;\n    _this._lastYFix = null;\n    _this._initialX = null;\n    _this._initialY = null;\n    _this._initialTop = null;\n    _this._initialLeft = null;\n    _this._child = null;\n    _this._toggle = null;\n    return _this;\n  }\n\n  Layover.prototype.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    if (process.env.NODE_ENV === 'development') {\n      window.addEventListener('load', function () {\n        _this2._setContainer(_this2._container);\n      });\n    }\n\n    var _props = this.props,\n        visible = _props.visible,\n        fixedTo = _props.fixedTo,\n        sameWidth = _props.sameWidth,\n        centered = _props.centered,\n        simplified = _props.simplified;\n\n    var anchor = this._getAnchor(this.props);\n\n    if (visible) {\n      handleWindowClickListeners(this._handleOutsideClick, true); // Don't worry about any of the other logic for a \"simple\" layover\n\n      if (simplified) {\n        return;\n      }\n\n      var rect = this._contextRect || this._toggle.getBoundingClientRect();\n\n      if (this._dialog) {\n        this._manageFixedToListener(this._dialog, true);\n      } else if (!this._inFixed) {\n        this._manageFixedToListener(fixedTo, true);\n      }\n\n      this._init(fixedTo, anchor, sameWidth, centered, rect);\n    }\n  };\n\n  Layover.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var fixedTo = nextProps.fixedTo,\n        visible = nextProps.visible,\n        children = nextProps.children,\n        sameWidth = nextProps.sameWidth,\n        centered = nextProps.centered,\n        simplified = nextProps.simplified;\n\n    if (simplified) {\n      if (this.props.simplified !== simplified) {\n        this._reset();\n      }\n\n      return;\n    }\n\n    var anchor = this._getAnchor(nextProps);\n\n    var visibileDiff = visible !== this.props.visible;\n    var childStyle = React.Children.only(children).props.style;\n\n    if (visibileDiff) {\n      if (!visible) {\n        this._reset();\n      } else {\n        // Initialize the layover logic\n        var rect = this._contextRect || this._toggle.getBoundingClientRect();\n\n        if (this._dialog) {\n          this._manageFixedToListener(this._dialog, true);\n        } else if (!this._inFixed) {\n          this._manageFixedToListener(fixedTo, true);\n        }\n\n        this._init(fixedTo, anchor, sameWidth, centered, rect);\n      }\n    } else if (fixedTo !== this.props.fixedTo && visible) {\n      // swap the fixedTo listeners\n      this._manageFixedToListener(this.props.fixedTo, false);\n\n      this._manageFixedToListener(fixedTo, true);\n    } else if (childStyle !== React.Children.only(this.props.children).props.style) {\n      // Re-merge styles... This is only required if all the others fail since all the other\n      // logic always merges styles with the children styles\n      this.setState({\n        styles: _extends({}, this.state.styles, childStyle)\n      });\n    }\n  };\n\n  Layover.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var _this3 = this;\n\n    var _props2 = this.props,\n        visible = _props2.visible,\n        closeOnOutsideClick = _props2.closeOnOutsideClick;\n    var enabled = visible && closeOnOutsideClick;\n    var prevEnabled = prevProps.visible && prevProps.closeOnOutsideClick;\n\n    if (enabled !== prevEnabled) {\n      if (this._clickTimeout) {\n        clearTimeout(this._clickTimeout);\n        this._clickTimeout = null;\n      } // This is really an arbitrary timeout time, but firefox needs to have a timeout\n      // so the context menu doesn't close automatically due to an \"outside click\" being\n      // triggered\n\n\n      this._clickTimeout = setTimeout(function () {\n        _this3._clickTimeout = null;\n        handleWindowClickListeners(_this3._handleOutsideClick, enabled);\n      }, enabled ? 300 : 0);\n    }\n  };\n\n  Layover.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this._clickTimeout) {\n      clearTimeout(this._clickTimeout);\n      this._clickTimeout = null;\n    }\n\n    handleWindowClickListeners(this._handleOutsideClick, false);\n\n    if (!this.props.simplified) {\n      this._manageFixedToListener(this.props.fixedTo, false);\n\n      this._manageWindowResizeListener(false);\n    }\n  };\n\n  Layover.prototype._getAnchor = function _getAnchor(_ref) {\n    var anchor = _ref.anchor,\n        belowAnchor = _ref.belowAnchor,\n        animationPosition = _ref.animationPosition;\n    return animationPosition === Layover.Positions.BELOW && belowAnchor || anchor;\n  };\n  /**\n   * One of the past versions of react-md introduced flex-positioned dialogs that\n   * no longer use a negative transform to center the dialogs. This function is\n   * normally called to update the position by re-adding the negative transform again\n   * back to the fixed element so it can be positioned correctly. So if this is\n   * a flex-positioned dialog, we don't need to do this hack.\n   */\n\n  /**\n   * Whew. Ok. So since the fixedTo prop can either be two elements or a single item,\n   * this utility function is used to add/remove the scrolling event listeners for\n   * this prop.\n   *\n   * When the fixedTo prop has a horizontal and/or vertical attribute, the `window`\n   * will be the fallback option. If both the horizontal and vertical attributes are\n   * defined, the `window` still needs to have a scroll listener to make sure it\n   * doesn't go off screen.\n   */\n\n  /**\n   * This is just a simple utility function to merge the existing state styles,\n   * any new styles, and the children's styles (with most precedence).\n   */\n\n  /**\n   * This initializes the popover with the default styles, and the initial bookkeeping\n   * variables to update while it is open.\n   */\n\n  /**\n   * Attempts to fix the child by setting it's location ONLY for the entire\n   * page viewport. I didn't bother attempting to fix it for additional fixedTo\n   * stuff.\n   */\n\n  /**\n   * When the child is initially mounted, it will update the styles for centering\n   * the element (if enabled) and then attempt to fix any viewport issues.\n   */\n\n  /**\n   * This is the meat of the stuff. Do lots of viewport / container checks to make sure\n   * the element should still be visible. If it is still visible, it will update its\n   * x and y position for the new scroll position.\n   */\n\n  /**\n   * Attempts to fix a viewport problem by swapping the positioning. This only does\n   * vertical switching right now.\n   *\n   * @param {Object} vp - The result of the viewport function\n   * @return {boolean} true if the fix was able to be done and successful.\n   */\n\n\n  Layover.prototype.render = function render() {\n    var _props3 = this.props,\n        className = _props3.className,\n        block = _props3.block,\n        toggle = _props3.toggle,\n        visible = _props3.visible,\n        children = _props3.children,\n        fullWidth = _props3.fullWidth,\n        animationPosition = _props3.animationPosition,\n        simplified = _props3.simplified,\n        fillViewportWidth = _props3.fillViewportWidth,\n        fillViewportHeight = _props3.fillViewportHeight,\n        anchor = _props3.anchor,\n        belowAnchor = _props3.belowAnchor,\n        onClose = _props3.onClose,\n        repositionOnScroll = _props3.repositionOnScroll,\n        repositionOnResize = _props3.repositionOnResize,\n        sameWidth = _props3.sameWidth,\n        centered = _props3.centered,\n        fixedTo = _props3.fixedTo,\n        toggleQuery = _props3.toggleQuery,\n        yThreshold = _props3.yThreshold,\n        xThreshold = _props3.xThreshold,\n        onContextMenu = _props3.onContextMenu,\n        preventContextMenu = _props3.preventContextMenu,\n        closeOnOutsideClick = _props3.closeOnOutsideClick,\n        minLeft = _props3.minLeft,\n        minRight = _props3.minRight,\n        minBottom = _props3.minBottom,\n        props = _objectWithoutProperties(_props3, ['className', 'block', 'toggle', 'visible', 'children', 'fullWidth', 'animationPosition', 'simplified', 'fillViewportWidth', 'fillViewportHeight', 'anchor', 'belowAnchor', 'onClose', 'repositionOnScroll', 'repositionOnResize', 'sameWidth', 'centered', 'fixedTo', 'toggleQuery', 'yThreshold', 'xThreshold', 'onContextMenu', 'preventContextMenu', 'closeOnOutsideClick', 'minLeft', 'minRight', 'minBottom']);\n\n    var child = void 0;\n    var childId = void 0;\n\n    if (visible) {\n      child = React.Children.only(children);\n\n      if (child.props.id) {\n        childId = child.props.id;\n      } else if (props.id) {\n        childId = props.id + '-layover';\n      }\n\n      child = React.cloneElement(children, {\n        ref: this._fixateChild,\n        id: childId,\n        style: simplified ? child.props.style : this.state.styles,\n        className: cn('md-layover-child md-layover-child--' + animationPosition, {\n          'md-layover-child--simplified': simplified\n        }, child.props.className)\n      });\n    }\n\n    var observer = null;\n\n    if (!simplified && !fillViewportWidth && !fillViewportHeight) {\n      observer = React.createElement(ResizeObserver, {\n        watchWidth: !fillViewportWidth,\n        watchHeight: !fillViewportHeight,\n        target: this._child,\n        onResize: this._handleResize\n      });\n    }\n\n    return React.createElement(CSSTransitionGroup, _extends({}, props, {\n      className: cn('md-layover', {\n        'md-layover--simplified': simplified,\n        'md-inline-block': !block && !fullWidth,\n        'md-full-width': fullWidth\n      }, className),\n      ref: this._setContainer,\n      'aria-haspopup': true,\n      'aria-owns': childId,\n      'aria-expanded': visible,\n      transitionEnter: props.transitionEnterTimeout !== 0,\n      transitionLeave: props.transitionLeaveTimeout !== 0,\n      onContextMenu: this._handleContextMenu\n    }), observer, toggle, child);\n  };\n\n  return Layover;\n}(PureComponent);\n\nLayover.HorizontalAnchors = HorizontalAnchors;\nLayover.VerticalAnchors = VerticalAnchors;\nLayover.Positions = Positions;\nLayover.propTypes = {\n  /**\n   * A id to give the layover itself. This is generally recommended for accessibility. If the\n   * child does not have an id, the child will automatically be updated to be `${id}-layover`.\n   */\n  id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * An optional style to apply to the layover.\n   */\n  style: PropTypes.object,\n\n  /**\n   * An optional className to apply to the layover.\n   */\n  className: PropTypes.string,\n\n  /**\n   * Boolean if the layover's child is currently visible.\n   */\n  visible: PropTypes.bool.isRequired,\n\n  /**\n   * This should either be a single element or two elements that the layover recalculates\n   * its fixed position when scrolling for horizontal and vertical.\n   *\n   * When it is a single element, it will recalculate for both horizontal and vertical\n   * scrolling. Otherwise, you can specify the element for horizontal scrolling and a\n   * separate element for vertical scrolling. If one is omitted, it will default to `window`.\n   *\n   * If the component is no longer considered to be in view after scrolling, the `onClose`\n   * prop will be called.\n   */\n  fixedTo: fixedToShape.isRequired,\n\n  /**\n   * The renderable item that causes the Layover to become visible. This _should_\n   * most likely be an `element` or `arrayOf(element)`, but anything is allowed.\n   */\n  toggle: PropTypes.node,\n\n  /**\n   * Since the `toggle` prop can be anything, I need a way to be able to find an\n   * element to base all the calculations on. This can either be a string that\n   * gets passed to `layover.querySelector`, a DOM Element, or a function that\n   * returns a DOM Element.\n   */\n  toggleQuery: PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.string]).isRequired,\n\n  /**\n   * A single child that should be fixed to the toggle element.\n   */\n  children: PropTypes.element.isRequired,\n\n  /**\n   * Boolean if the Layover should be displayed as a block instead of as an inline block.\n   */\n  block: PropTypes.bool,\n\n  /**\n   * Boolean if the `children` should be centered horizontally and vertically while keeping\n   * its height in mind as well. This is *only* valid if both the x and y `anchor` targets\n   * are `CENTER`.\n   */\n  centered: PropTypes.bool,\n\n  /**\n   * Boolean if the layover should gain the `md-full-width` class name.\n   */\n  fullWidth: PropTypes.bool,\n\n  /**\n   * Boolean if the width of the children should be updated automatically to be the width\n   * of the toggle element.\n   */\n  sameWidth: PropTypes.bool,\n\n  /**\n   * The minimum value the `left` style can be for the child component. This is really just used\n   * to make sure it doesn't scroll off the left of the page. It can also be used to make\n   * full screen layovers on devices when when the `fillViewportWidth` prop is enabled.\n   *\n   * This can either be a number of pixels or a string for percentages. If this value is a string\n   * **it will always be used over the calculated values** so it is preferred to use a number.\n   *\n   * @see {@link #minRight}\n   * @see {@link #fillViewportWidth}\n   */\n  minLeft: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n\n  /**\n   * The minimum value the `right` style can be for the child component. This is really just used\n   * to make sure it doesn't scroll off the right of the page when the `fillViewportWidth` prop is\n   * enabled.\n   *\n   * This can either be a number of pixels or a string for percentages. If this value is a string\n   * **it will always be used over the calculated values** so it is preferred to use a number.\n   *\n   * @see {@link #minLeft}\n   * @see {@link #fillViewportWidth}\n   */\n  minRight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n\n  /**\n   * The minimum value that can be used for the `bottom` prop when the `fillViewportHeight` prop is enabled.\n   * It is generally recommended to keep this value at `0` to keep it stretched to the bottom of the viewport\n   * or setting it to a small positive number to add some padding.\n   *\n   * This can either be a number of pixels or a string for percentages. If this value is a string\n   * **it will always be used over the calculated values** so it is preferred to use a number.\n   *\n   * @see {@link #fillViewportHeight}\n   */\n  minBottom: PropTypes.number.isRequired,\n\n  /**\n   * Boolean if the layover should make the child fill the entire viewport's width. This will just\n   * style the child element with:\n   *\n   * ```js\n   * childStyle = {\n   *   left: this.props.minLeft,\n   *   right: this.props.minRight,\n   * };\n   * ```\n   *\n   * If you add any additional constraints such as `width` or `max-width`, it will not span the entire viewport's\n   * width. This prop should generally really only be used on mobile devices. Using this prop along with\n   * `fillViewportHeight` for Autocompletes can create great Android mobile searches. See the `fillViewportHeight`\n   * for more information about why it is *only Android*.\n   *\n   * @see {@link #minLeft}\n   * @see {@link #minRight}\n   * @see {@link #fillViewportHeight}\n   */\n  fillViewportWidth: PropTypes.bool,\n\n  /**\n   * Boolean if the layover should fill the height of the viewport from the current calculated `top`. This will just\n   * style the child element with:\n   *\n   * ```js\n   * childStyle = {\n   *   top: currentCalculatedTop,\n   *   bottom: this.props.minBottom,\n   *   maxHeight: 'none',\n   * };\n   * ```\n   *\n   * This is *super* nice on Android devices since it will allow you to create nice toolbar search autocompletes\n   * in your app and the list of items will grow until it reaches the soft keyboard. It isn't as nice on iOS since\n   * iOS does not subtract the soft keyboard from the viewport's size so the list will still extend to the bottom\n   * of the page.\n   *\n   * @see {@link #minBottom}\n   * @see {@link #fillViewportWidth}\n   */\n  fillViewportHeight: PropTypes.bool,\n\n  /**\n   * A function used to hide the visibility of the children when the children are no longer\n   * visible or an element outside of the layover is clicked.\n   */\n  onClose: PropTypes.func.isRequired,\n\n  /**\n   * The component to render the Layover as.\n   */\n  component: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]).isRequired,\n\n  /**\n   * The transition name to use for the children appearing/disappearing.\n   */\n  transitionName: PropTypes.string.isRequired,\n\n  /**\n   * The transition duration for the enter animation. The animation can be disabled by setting\n   * this value to 0.\n   */\n  transitionEnterTimeout: PropTypes.number.isRequired,\n\n  /**\n   * The transition duration for the leave animation. The animation can be disabled by setting\n   * this value to 0.\n   */\n  transitionLeaveTimeout: PropTypes.number.isRequired,\n\n  /**\n   * This is a threshold that is used to calculate if the `children` is still in\n   * view by applying this multiplier to the `children`'s width.\n   */\n  xThreshold: PropTypes.number.isRequired,\n\n  /**\n   * This is a threshold that is used to calculate if the `children` is still in\n   * view by applying this multiplier to the `toggle`'s height.\n   */\n  yThreshold: PropTypes.number.isRequired,\n\n  /**\n   * Boolean if the `children` should be hidden when an element outside\n   * of the `Layout` component has been clicked.\n   */\n  closeOnOutsideClick: PropTypes.bool.isRequired,\n\n  /**\n   * This is how the children get \"anchored\" to the `toggle` element and how the\n   * auto-fix attempts will be made. Right now, the auto fixes will only be handled\n   * on viewport boundaries instead of `fixedTo` boundaries. It was too hard for\n   * first attempt.\n   *\n   * The general behavior will be that an equal-opposite of an anchor will be chosen\n   * when that direction is out of viewport. So for example, the children are out\n   * of viewport for the right of the screen, and the `anchor.x` value is\n   * `Layover.HorizontalPositions.RIGHT`, the children will be swapped to be the `LEFT`\n   * of the `toggle` component now.\n   *\n   * So a full list:\n   * - `LEFT` / `RIGHT`\n   * - `INNER_LEFT` / `INNER_RIGHT`\n   * - `TOP` / `BOTTOM`\n   *\n   * The `CENTER` and `OVERLAP` positions can not be automatically adjusted.\n   *\n   * > To be safe, you should use the enum values for the `x` and `y` values.\n   * @see {@link #VerticalAnchors}\n   * @see {@link #HorizontalAnchors}\n   */\n  anchor: anchorShape.isRequired,\n\n  /**\n   * This is how the children get \"anchored\" when the `animationPositions` is set to `Layover.Positions.BELOW`.\n   * Set this to `null` to continue using the base `anchor` prop instead of switching to this anchor.\n   *\n   * @see {@link #anchor}\n   */\n  belowAnchor: anchorShape,\n\n  /**\n   * This is the position that the children should animate from. It directly ties into\n   * the `$md-layover-child-positions` Sass variable.\n   */\n  animationPosition: positionShape.isRequired,\n\n  /**\n   * If you would like the layover to interact as a context menu, provide this prop. It will\n   * make the children appear relative to the context menu origin automatically.\n   *\n   * @see {@link #preventContextMenu}\n   */\n  onContextMenu: PropTypes.func,\n\n  /**\n   * Boolean if the default behavior of the context menu should be prevented when using the\n   * `onContextMenu` prop.\n   *\n   * @see {@link #onContextMenu}\n   */\n  preventContextMenu: PropTypes.bool,\n\n  /**\n   * Boolean if the layover should attempt to automatically adjust the position of the element to\n   * keep it within the viewport. If this value is set to `false`, the `onClose` prop will be called\n   * instead.\n   */\n  repositionOnScroll: PropTypes.bool,\n\n  /**\n   * Boolean if the layover should attempt to automatically adjust the position of the element to\n   * keep it within the viewport. If this value is set to `false`, the `onClose` prop will be called\n   * instead.\n   */\n  repositionOnResize: PropTypes.bool,\n\n  /**\n   * Boolean if the layover should become \"simplified\". This basically disables all the logic for\n   * keeping the child within the viewport and allows you to manage all the positioning via CSS.\n   *\n   * When this is enabled, it updates the `Layover` to have `position: relative` while the child will\n   * have `position: absolute` which will allow for simple `top`, `right`, `bottom`, and/or `left` CSS\n   * to position as wanted.\n   *\n   * This is really only helpful in cases where the layover can't calculate things correctly due to\n   * being in fixed containers somewhere in the page or some other weird stuff. Hopefully this won't\n   * really need to be used much.\n   */\n  simplified: PropTypes.bool\n};\nLayover.defaultProps = {\n  anchor: {\n    x: Layover.HorizontalAnchors.INNER_LEFT,\n    y: Layover.VerticalAnchors.OVERLAP\n  },\n  belowAnchor: {\n    x: Layover.HorizontalAnchors.CENTER,\n    y: Layover.VerticalAnchors.BOTTOM\n  },\n  animationPosition: Layover.Positions.BELOW,\n  repositionOnScroll: true,\n  repositionOnResize: false,\n  component: 'div',\n  fixedTo: typeof window !== 'undefined' ? window : {},\n  toggleQuery: '.md-text-field-container,button,*[role=\"button\"],*[role=\"listbox\"]',\n  transitionName: 'md-layover',\n  transitionEnterTimeout: 200,\n  transitionLeaveTimeout: 200,\n  yThreshold: 0.38,\n  xThreshold: 0.38,\n  closeOnOutsideClick: true,\n  preventContextMenu: true,\n  simplified: false,\n  minLeft: 0,\n  minRight: 0,\n  minBottom: 0,\n  fillViewportWidth: false,\n  fillViewportHeight: false\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this4 = this;\n\n  this._isCenteredDialog = function () {\n    return _this4._dialog && _this4._dialog.classList.contains('md-dialog--centered') && window.getComputedStyle(_this4._dialog).transform !== 'none';\n  };\n\n  this._createStyles = function (anchor, centered, child, rect) {\n    var x = anchor.x,\n        y = anchor.y;\n    var offsetWidth = child.offsetWidth,\n        offsetHeight = child.offsetHeight;\n    var left = void 0;\n    var top = void 0;\n\n    if (x === HorizontalAnchors.CENTER) {\n      left = rect.left + rect.width / 2 - offsetWidth / 2;\n    } else if (x === HorizontalAnchors.INNER_RIGHT) {\n      left = rect.right - offsetWidth;\n    } else if (x === HorizontalAnchors.LEFT) {\n      left = rect.left - offsetWidth;\n    } else if (x === HorizontalAnchors.RIGHT) {\n      left = rect.right;\n    }\n\n    if (centered && x === HorizontalAnchors.CENTER && y === VerticalAnchors.CENTER) {\n      top = rect.top - offsetHeight / 2 + rect.height / 2;\n    } else if (y === VerticalAnchors.TOP) {\n      top = rect.top - offsetHeight;\n    } else if (y === VerticalAnchors.CENTER) {\n      top = rect.top + rect.height / 2;\n    } else if (y === VerticalAnchors.BOTTOM) {\n      top = rect.bottom;\n    }\n\n    if (_this4._isCenteredDialog()) {\n      var dialogRect = _this4._dialog.getBoundingClientRect();\n\n      left -= dialogRect.left;\n      top -= dialogRect.top;\n    }\n\n    var style = {};\n\n    if (top) {\n      style.top = top;\n    }\n\n    if (left) {\n      style.left = left;\n    }\n\n    return style;\n  };\n\n  this._manageFixedToListener = function (fixedTo, add) {\n    var listener = (add ? 'add' : 'remove') + 'EventListener';\n\n    if (fixedTo !== window && (fixedTo.x || fixedTo.y)) {\n      var x = fixedTo.x,\n          y = fixedTo.y;\n\n      if (x) {\n        x[listener]('scroll', _this4._handleScroll);\n      } else {\n        window[listener]('scroll', _this4._handleScroll);\n      }\n\n      if (y) {\n        y[listener]('scroll', _this4._handleScroll);\n      } else if (!x) {\n        // Only add the window event listener once\n        window[listener]('scroll', _this4._handleScroll);\n      }\n\n      if (y && y !== window && x && x !== window) {\n        window[listener]('scroll', _this4._handleScroll);\n      }\n    } else {\n      fixedTo[listener]('scroll', _this4._handleScroll);\n\n      if (fixedTo !== window) {\n        window[listener]('scroll', _this4._handleScroll);\n      }\n    }\n  };\n\n  this._manageWindowResizeListener = function (enabled) {\n    if (_this4._windowResizeTimeout) {\n      clearTimeout(_this4._windowResizeTimeout);\n      _this4._windowResizeTimeout = null;\n    }\n\n    if (enabled) {\n      // add a 2 second delay before watching resize events since Android soft keyboards trigger a resize event.\n      _this4._windowResizeTimeout = setTimeout(function () {\n        _this4._windowResizeTimeout = null;\n        window.addEventListener('resize', _this4._handleWindowResize);\n      }, 2000);\n    } else {\n      window.removeEventListener('resize', _this4._handleWindowResize);\n    }\n  };\n\n  this._mergeStyles = function (style) {\n    var _props4 = _this4.props,\n        minLeft = _props4.minLeft,\n        minRight = _props4.minRight,\n        minBottom = _props4.minBottom,\n        fillViewportWidth = _props4.fillViewportWidth,\n        fillViewportHeight = _props4.fillViewportHeight;\n\n    if (fillViewportWidth) {\n      style.left = minLeft;\n      style.right = minRight;\n    } else {\n      if (style.left) {\n        style.left = Math.max(minLeft, style.left);\n      }\n\n      if (style.right) {\n        style.right = Math.max(minRight, style.right);\n      }\n    }\n\n    if (fillViewportHeight) {\n      style.bottom = minBottom;\n      style.maxHeight = 'none';\n    } else {\n      // These styles are only created when filling the viewport height, so clear\n      // them out again\n      style.bottom = null;\n      style.maxHeight = null;\n    }\n\n    return _extends({}, _this4.state.styles, style, React.Children.only(_this4.props.children).props.style);\n  };\n\n  this._init = function (fixedTo, anchor, sameWidth, centered, rect) {\n    if (_this4._child) {\n      // The init function can be called again if the user quickly toggles the layover. If that\n      // is the case, we want the styles that were set after the _positionChild _attemptFix.\n      return;\n    }\n\n    var height = rect.height,\n        width = rect.width;\n    var top = rect.top,\n        left = rect.left,\n        right = rect.right;\n    var x = void 0;\n    var y = void 0;\n\n    if (_this4._dialog) {\n      var scroll = getScroll(_this4._dialog);\n      x = scroll.x;\n      y = scroll.y;\n\n      if (_this4._isCenteredDialog()) {\n        var dialogRect = _this4._dialog.getBoundingClientRect();\n\n        left -= dialogRect.left;\n        top -= dialogRect.top;\n        right -= dialogRect.right;\n      }\n    } else if (fixedTo !== window && (fixedTo.y || fixedTo.x)) {\n      x = getScroll(fixedTo.x || window).x;\n      y = getScroll(fixedTo.y || window).y;\n    } else {\n      var _scroll = getScroll(fixedTo);\n\n      x = _scroll.x;\n      y = _scroll.y;\n    }\n\n    _this4._initialX = x;\n    _this4._initialY = y;\n    _this4._initialLeft = left;\n    _this4._initialTop = top;\n\n    if (anchor.x === HorizontalAnchors.INNER_RIGHT) {\n      _this4._initialLeft = left + width;\n    } else if (anchor.x === HorizontalAnchors.RIGHT) {\n      _this4._initialLeft = right;\n    }\n\n    if (!centered) {\n      _this4._lastYFix = anchor.y === VerticalAnchors.TOP ? 'bottom' : 'top';\n    } else {\n      // Centered is not fixable\n      _this4._lastYFix = null;\n    }\n\n    if (anchor.x === HorizontalAnchors.LEFT || anchor.x === HorizontalAnchors.INNER_LEFT) {\n      _this4._lastXFix = 'right';\n    } else if (anchor.x === HorizontalAnchors.RIGHT || anchor.x === HorizontalAnchors.INNER_RIGHT) {\n      _this4._lastXFix = 'left';\n    } else {\n      // Can't fix others\n      _this4._lastXFix = null;\n    }\n\n    if (anchor.y === VerticalAnchors.BOTTOM) {\n      _this4._initialTop = top + height;\n    }\n\n    if (fixedTo !== window && !fixedTo.y && !fixedTo.x) {\n      var _scroll2 = getScroll(window);\n\n      _this4._initialWinX = _scroll2.x;\n      _this4._initialWinY = _scroll2.y;\n    }\n\n    var styles = _this4._mergeStyles({\n      left: _this4._initialLeft,\n      top: _this4._initialTop,\n      transformOrigin: undefined,\n      width: sameWidth ? width : undefined\n    });\n\n    _this4.setState({\n      styles: styles\n    });\n  };\n\n  this._reset = function () {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this4.props,\n        fixedTo = _ref2.fixedTo; // Reset all the bookkeeping variables for a fresh start on re-visible\n\n\n    _this4._lastXFix = null;\n    _this4._lastYFix = null;\n    _this4._initialX = null;\n    _this4._initialY = null;\n    _this4._initialTop = null;\n    _this4._initialLeft = null;\n\n    if (!_this4._inFixed) {\n      if (_this4._dialog) {\n        _this4._manageFixedToListener(_this4._dialog, false);\n      }\n\n      _this4._manageFixedToListener(fixedTo, false);\n    }\n  };\n\n  this._setContainer = function (container) {\n    _this4._container = findDOMNode(container);\n    _this4._toggle = null;\n\n    if (!_this4._container) {\n      return;\n    }\n\n    var _props5 = _this4.props,\n        toggleQuery = _props5.toggleQuery,\n        onContextMenu = _props5.onContextMenu;\n\n    if (typeof toggleQuery === 'function') {\n      _this4._toggle = toggleQuery();\n    } else if (typeof toggleQuery === 'string') {\n      _this4._toggle = _this4._container.querySelector(toggleQuery);\n    } else {\n      _this4._toggle = toggleQuery;\n    }\n\n    if (!_this4._toggle && !onContextMenu && process.env.NODE_ENV !== 'production') {\n      var error = new Error('Unable to find a toggle component with the provided `toggleQuery` and `toggle` element. \\n' + ('`toggleQuery`: `' + toggleQuery + '`'));\n      error.toggleQuery = toggleQuery;\n      error.toggle = _this4.props.toggle;\n      throw error;\n    }\n\n    var node = _this4._container;\n\n    while (node && node !== document) {\n      var fixed = window.getComputedStyle(node).position === 'fixed';\n\n      if (fixed && node.className.match(/md-dialog--(full-page|centered)/)) {\n        _this4._dialog = node;\n        return;\n      } else if (fixed && !node.classList.contains('md-layover-child')) {\n        _this4._inFixed = true;\n        return;\n      }\n\n      node = node.offsetParent || node.parentNode;\n    }\n  };\n\n  this._initialFix = function () {\n    // Need to make a clone that disables any transitions to calculate positioning stuff\n    var clone = _this4._child.cloneNode(true);\n\n    clone.style.webkitTransform = 'none';\n    clone.style.transfrom = 'none';\n    clone.style.webkitTransition = 'none';\n    clone.style.transition = 'none';\n\n    _this4._child.parentNode.appendChild(clone);\n\n    var vp = viewport(clone);\n    var childHeight = clone.offsetHeight,\n        childWidth = clone.offsetWidth;\n\n    _this4._child.parentNode.removeChild(clone);\n\n    if (vp === true || !_this4._toggle || !_this4._child) {\n      return;\n    }\n\n    var _getAnchor2 = _this4._getAnchor(_this4.props),\n        x = _getAnchor2.x,\n        y = _getAnchor2.y;\n\n    var toggleHeight = void 0;\n    var toggleWidth = void 0;\n\n    if (_this4._contextRect) {\n      toggleHeight = _this4._contextRect.height;\n      toggleWidth = _this4._contextRect.width;\n    } else {\n      toggleHeight = _this4._toggle.offsetHeight;\n      toggleWidth = _this4._toggle.offsetWidth;\n    }\n\n    var addToTop = 0;\n    var addToLeft = 0; // Android devices will never get this far because they consider the keyboard as part\n    // of the viewport, iOS will and cause it to be a giant negative number. *sigh*\n    // Prevent any additional vertical positioning for iOS\n\n    if (!_this4.props.fillViewportHeight && (!vp.top || !vp.bottom)) {\n      var multiplier = vp.top ? -1 : 1;\n\n      if (!vp.bottom && y === VerticalAnchors.OVERLAP) {\n        addToTop += toggleHeight;\n      } else if (y === VerticalAnchors.TOP || y === VerticalAnchors.BOTTOM) {\n        addToTop += multiplier * toggleHeight;\n      }\n\n      addToTop += multiplier * childHeight;\n      _this4._lastYFix = vp.top ? 'bottom' : 'top';\n    }\n\n    if (!_this4.props.fillViewportWidth && x !== HorizontalAnchors.CENTER && (!vp.left || !vp.right)) {\n      if (!vp.left && x === HorizontalAnchors.LEFT) {\n        addToLeft += toggleWidth + childWidth;\n        _this4._lastXFix = 'left';\n      } else if (!vp.left && x === HorizontalAnchors.INNER_LEFT) {\n        addToLeft += toggleWidth;\n        _this4._lastXFix = 'left';\n      } else if (!vp.right && x === HorizontalAnchors.RIGHT) {\n        addToLeft -= toggleWidth + childWidth;\n        _this4._lastXFix = 'right';\n      } else if (!vp.right && x === HorizontalAnchors.INNER_RIGHT) {\n        addToLeft -= toggleWidth;\n        _this4._lastXFix = 'right';\n      }\n    }\n\n    if (addToTop !== 0 || addToLeft !== 0) {\n      _this4._initialTop += addToTop;\n      _this4._initialLeft += addToLeft;\n\n      _this4.setState({\n        styles: _this4._mergeStyles({\n          top: _this4._initialTop,\n          left: _this4._initialLeft\n        })\n      });\n    }\n  };\n\n  this._fixateChild = function (child) {\n    _this4._child = findDOMNode(child);\n\n    if (_this4._child !== null) {\n      _this4._childComponent = React.Children.only(_this4.props.children); // If child also has a ref callback, simulate the same thing\n\n      if (typeof _this4._childComponent.ref === 'function') {\n        _this4._childComponent.ref(child);\n      }\n\n      if (_this4.props.simplified || !_this4._child || !_this4._toggle && !_this4._contextRect) {\n        return;\n      }\n\n      _this4._manageWindowResizeListener(true);\n\n      _this4._positionChild();\n    } else if (_this4._childComponent && typeof _this4._childComponent.ref === 'function') {\n      _this4._childComponent.ref(child);\n    }\n  };\n\n  this._positionChild = function () {\n    var centered = _this4.props.centered;\n\n    var anchor = _this4._getAnchor(_this4.props);\n\n    var rect = _this4._contextRect || _this4._toggle.getBoundingClientRect();\n\n    _this4._height = rect.height;\n    _this4._width = rect.width;\n\n    var styles = _this4._createStyles(anchor, centered, _this4._child, rect);\n\n    if (styles.top || styles.left) {\n      _this4._initialLeft = styles.left || _this4._initialLeft;\n      _this4._initialTop = styles.top || _this4._initialTop;\n\n      _this4.setState({\n        styles: _this4._mergeStyles(styles)\n      }, _this4._initialFix);\n    } else {\n      _this4._initialFix();\n    }\n  };\n\n  this._handleResize = function () {\n    if (_this4.props.visible) {\n      _this4._positionChild();\n    }\n  };\n\n  this._handleScroll = function (e) {\n    if (!_this4.props.repositionOnScroll) {\n      _this4._manageFixedToListener(_this4.props.fixedTo, false);\n\n      _this4.props.onClose(e);\n    }\n\n    if (!_this4._ticking) {\n      requestAnimationFrame(function () {\n        return _this4._handleTick(e);\n      });\n    }\n\n    _this4._ticking = true;\n  };\n\n  this._handleTick = function (e) {\n    var _props6 = _this4.props,\n        fixedTo = _props6.fixedTo,\n        xThreshold = _props6.xThreshold,\n        yThreshold = _props6.yThreshold;\n    var vp = viewport(_this4._child);\n\n    if (vp !== true && vp.left && vp.right) {\n      var fixed = !_this4._contextRect && _this4._attemptFix(vp);\n\n      if (!fixed) {\n        _this4.props.onClose(e);\n\n        _this4._ticking = false;\n      }\n\n      return;\n    } else if (isOutOfBounds(fixedTo, _this4._child, _this4._toggle, yThreshold, xThreshold)) {\n      _this4.props.onClose(e);\n\n      _this4._ticking = false;\n      return;\n    }\n\n    var x = void 0;\n    var y = void 0;\n\n    if (_this4._dialog) {\n      var scroll = getScroll(_this4._dialog);\n      x = scroll.x;\n      y = scroll.y;\n    } else if (fixedTo !== window && (fixedTo.x || fixedTo.y)) {\n      x = getScroll(fixedTo.x || window).x;\n      y = getScroll(fixedTo.y || window).y;\n    } else {\n      var _scroll3 = getScroll(fixedTo);\n\n      x = _scroll3.x;\n      y = _scroll3.y;\n    }\n\n    var winX = void 0;\n    var winY = void 0; // When using the additional fixedTo stuff, need to also keep track of the entire\n    // window's scrolling..\n\n    if (fixedTo !== window && !fixedTo.x && !fixedTo.y) {\n      var _scroll4 = getScroll(window);\n\n      winX = _scroll4.x;\n      winY = _scroll4.y;\n    }\n\n    var styles = _this4.state.styles;\n    var left = styles.left,\n        top = styles.top;\n\n    if (_this4._initialX !== x) {\n      left = _this4._initialX - x + _this4._initialLeft;\n    }\n\n    if (winX && _this4._initialWinX !== winX) {\n      left = _this4._initialWinX - winX + _this4._initialX;\n    }\n\n    if (_this4._initialY !== y) {\n      top = _this4._initialY - y + _this4._initialTop;\n    }\n\n    if (winY && _this4._initialWinY !== winY) {\n      top = _this4._initialWinY - winY + _this4._initialTop + (_this4._initialY - y);\n    }\n\n    if (styles.top !== top || styles.left !== left) {\n      _this4.setState({\n        styles: _this4._mergeStyles({\n          left: left,\n          top: top\n        })\n      }, function () {\n        _this4._ticking = false;\n      });\n    } else {\n      _this4._ticking = false;\n    }\n  };\n\n  this._handleOutsideClick = function (e) {\n    if (_this4._contextRect && _this4._child && !_this4._child.contains(e.target) || _this4._container && !_this4._container.contains(e.target)) {\n      _this4.props.onClose(e);\n    }\n  };\n\n  this._handleWindowResize = function (e) {\n    var _props7 = _this4.props,\n        onClose = _props7.onClose,\n        repositionOnResize = _props7.repositionOnResize;\n\n    if (repositionOnResize) {\n      _this4._handleResize();\n    } else {\n      onClose(e);\n\n      _this4._manageWindowResizeListener(false);\n    }\n  };\n\n  this._attemptFix = function (vp) {\n    var _getAnchor3 = _this4._getAnchor(_this4.props),\n        x = _getAnchor3.x,\n        y = _getAnchor3.y;\n\n    var centered = x === HorizontalAnchors.CENTER && y === VerticalAnchors.CENTER && _this4.props.centered;\n\n    if (centered || _this4._lastYFix === 'top' && !vp.top || _this4._lastYFix === 'bottom' && !vp.bottom) {\n      return false;\n    }\n\n    var toggleTop = _this4._toggle.getBoundingClientRect().top;\n\n    var toggleHeight = _this4._toggle.offsetHeight;\n    var childHeight = _this4._child.offsetHeight; // Can;t fix if the child can't fit on the page based on the toggle's position\n\n    if (toggleTop + toggleHeight + childHeight > window.innerHeight) {\n      return false;\n    }\n\n    var _child$getBoundingCli = _this4._child.getBoundingClientRect(),\n        top = _child$getBoundingCli.top;\n\n    var newTop = _this4._initialTop;\n    var addToTop = childHeight * (vp.top ? -1 : 1);\n\n    if (y === VerticalAnchors.OVERLAP) {\n      addToTop += (vp.top ? 1 : -1) * toggleHeight;\n    } else if (y === VerticalAnchors.TOP || y === VerticalAnchors.BOTTOM) {\n      addToTop += (_this4._lastYFix === 'top' ? -1 : 1) * toggleHeight;\n    }\n\n    if (addToTop !== 0) {\n      newTop = top + addToTop;\n      _this4._lastYFix = vp.top ? 'bottom' : 'top';\n    }\n\n    if (newTop !== _this4._initialTop) {\n      _this4._initialTop = newTop;\n      var fixedTo = _this4.props.fixedTo;\n      var scrollEl = fixedTo;\n\n      if (fixedTo !== window && (fixedTo.y || fixedTo.x)) {\n        scrollEl = fixedTo.y || window;\n      }\n\n      _this4._initialY = getScroll(scrollEl).y;\n\n      _this4.setState({\n        styles: _this4._mergeStyles({\n          top: _this4._initialTop\n        })\n      }, function () {\n        _this4._ticking = false;\n      });\n\n      return true;\n    }\n\n    return false;\n  };\n\n  this._handleContextMenu = function (e) {\n    var anchor = _this4._getAnchor(_this4.props);\n\n    var _props8 = _this4.props,\n        onContextMenu = _props8.onContextMenu,\n        preventContextMenu = _props8.preventContextMenu,\n        fixedTo = _props8.fixedTo,\n        sameWidth = _props8.sameWidth,\n        centered = _props8.centered,\n        visible = _props8.visible;\n\n    if (!onContextMenu) {\n      return;\n    }\n\n    _this4._contextRect = getSelectedTextPosition(e);\n\n    if (preventContextMenu && (!_this4._child || !_this4._child.contains(e.target))) {\n      e.preventDefault();\n    }\n\n    onContextMenu(e);\n\n    if (visible) {\n      _this4._init(fixedTo, anchor, sameWidth, centered, _this4._contextRect);\n    }\n  };\n};\n\nexport default Layover;","map":{"version":3,"sources":["C:/Users/Sky/Desktop/info442/homeowork/node_modules/react-md/es/Helpers/Layover.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_objectWithoutProperties","obj","keys","indexOf","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","React","PureComponent","findDOMNode","PropTypes","CSSTransitionGroup","cn","handleWindowClickListeners","getSelectedTextPosition","getScroll","viewport","isOutOfBounds","anchorShape","fixedToShape","positionShape","HorizontalAnchors","VerticalAnchors","Positions","ResizeObserver","Layover","_PureComponent","props","_this","_initialiseProps","child","Children","only","children","state","below","right","styles","style","_lastXFix","_lastYFix","_initialX","_initialY","_initialTop","_initialLeft","_child","_toggle","componentDidMount","_this2","process","env","NODE_ENV","window","addEventListener","_setContainer","_container","_props","visible","fixedTo","sameWidth","centered","simplified","anchor","_getAnchor","_handleOutsideClick","rect","_contextRect","getBoundingClientRect","_dialog","_manageFixedToListener","_inFixed","_init","componentWillReceiveProps","nextProps","_reset","visibileDiff","childStyle","setState","componentDidUpdate","prevProps","_this3","_props2","closeOnOutsideClick","enabled","prevEnabled","_clickTimeout","clearTimeout","setTimeout","componentWillUnmount","_manageWindowResizeListener","_ref","belowAnchor","animationPosition","BELOW","render","_props3","className","block","toggle","fullWidth","fillViewportWidth","fillViewportHeight","onClose","repositionOnScroll","repositionOnResize","toggleQuery","yThreshold","xThreshold","onContextMenu","preventContextMenu","minLeft","minRight","minBottom","childId","id","cloneElement","ref","_fixateChild","observer","createElement","watchWidth","watchHeight","onResize","_handleResize","transitionEnter","transitionEnterTimeout","transitionLeave","transitionLeaveTimeout","_handleContextMenu","propTypes","oneOfType","number","string","object","bool","isRequired","node","func","element","component","transitionName","defaultProps","x","INNER_LEFT","y","OVERLAP","CENTER","BOTTOM","_this4","_isCenteredDialog","classList","contains","getComputedStyle","transform","_createStyles","offsetWidth","offsetHeight","left","top","width","INNER_RIGHT","LEFT","RIGHT","height","TOP","bottom","dialogRect","add","listener","_handleScroll","_windowResizeTimeout","_handleWindowResize","removeEventListener","_mergeStyles","_props4","Math","max","maxHeight","scroll","_scroll","_scroll2","_initialWinX","_initialWinY","transformOrigin","undefined","_ref2","container","_props5","querySelector","error","Error","document","fixed","position","match","offsetParent","parentNode","_initialFix","clone","cloneNode","webkitTransform","transfrom","webkitTransition","transition","appendChild","vp","childHeight","childWidth","removeChild","_getAnchor2","toggleHeight","toggleWidth","addToTop","addToLeft","multiplier","_childComponent","_positionChild","_height","_width","e","_ticking","requestAnimationFrame","_handleTick","_props6","_attemptFix","_scroll3","winX","winY","_scroll4","_props7","_getAnchor3","toggleTop","innerHeight","_child$getBoundingCli","newTop","scrollEl","_props8","preventDefault"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport React, { PureComponent } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport CSSTransitionGroup from 'react-transition-group/CSSTransitionGroup';\nimport cn from 'classnames';\n\nimport handleWindowClickListeners from '../utils/EventUtils/handleWindowClickListeners';\nimport getSelectedTextPosition from '../utils/Positioning/getSelectedTextPosition';\nimport getScroll from '../utils/Positioning/getScroll';\nimport viewport from '../utils/Positioning/viewport';\nimport isOutOfBounds from '../utils/Positioning/isOutOfBounds';\nimport anchorShape from './anchorShape';\nimport fixedToShape from './fixedToShape';\nimport positionShape from './positionShape';\nimport HorizontalAnchors from './HorizontalAnchors';\nimport VerticalAnchors from './VerticalAnchors';\nimport Positions from './Positions';\nimport ResizeObserver from './ResizeObserver';\n\n/**\n * The Layover component is used to keep a component fixed to another component\n * while the page is scrolling or a container is scrolling. When the fixed component\n * is considered out of view, it will be closed.\n *\n * > NOTE: Don't look at source code. Plz.\n */\n\nvar Layover = function (_PureComponent) {\n  _inherits(Layover, _PureComponent);\n\n  function Layover(props) {\n    _classCallCheck(this, Layover);\n\n    var _this = _possibleConstructorReturn(this, _PureComponent.call(this));\n\n    _initialiseProps.call(_this);\n\n    var child = React.Children.only(props.children);\n    _this.state = {\n      below: false,\n      right: false,\n      styles: child.props.style\n    };\n\n    _this._lastXFix = null;\n    _this._lastYFix = null;\n    _this._initialX = null;\n    _this._initialY = null;\n    _this._initialTop = null;\n    _this._initialLeft = null;\n    _this._child = null;\n    _this._toggle = null;\n    return _this;\n  }\n\n  Layover.prototype.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    if (process.env.NODE_ENV === 'development') {\n      window.addEventListener('load', function () {\n        _this2._setContainer(_this2._container);\n      });\n    }\n\n    var _props = this.props,\n        visible = _props.visible,\n        fixedTo = _props.fixedTo,\n        sameWidth = _props.sameWidth,\n        centered = _props.centered,\n        simplified = _props.simplified;\n\n    var anchor = this._getAnchor(this.props);\n    if (visible) {\n      handleWindowClickListeners(this._handleOutsideClick, true);\n\n      // Don't worry about any of the other logic for a \"simple\" layover\n      if (simplified) {\n        return;\n      }\n\n      var rect = this._contextRect || this._toggle.getBoundingClientRect();\n      if (this._dialog) {\n        this._manageFixedToListener(this._dialog, true);\n      } else if (!this._inFixed) {\n        this._manageFixedToListener(fixedTo, true);\n      }\n\n      this._init(fixedTo, anchor, sameWidth, centered, rect);\n    }\n  };\n\n  Layover.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var fixedTo = nextProps.fixedTo,\n        visible = nextProps.visible,\n        children = nextProps.children,\n        sameWidth = nextProps.sameWidth,\n        centered = nextProps.centered,\n        simplified = nextProps.simplified;\n\n    if (simplified) {\n      if (this.props.simplified !== simplified) {\n        this._reset();\n      }\n      return;\n    }\n\n    var anchor = this._getAnchor(nextProps);\n    var visibileDiff = visible !== this.props.visible;\n    var childStyle = React.Children.only(children).props.style;\n\n    if (visibileDiff) {\n      if (!visible) {\n        this._reset();\n      } else {\n        // Initialize the layover logic\n        var rect = this._contextRect || this._toggle.getBoundingClientRect();\n        if (this._dialog) {\n          this._manageFixedToListener(this._dialog, true);\n        } else if (!this._inFixed) {\n          this._manageFixedToListener(fixedTo, true);\n        }\n\n        this._init(fixedTo, anchor, sameWidth, centered, rect);\n      }\n    } else if (fixedTo !== this.props.fixedTo && visible) {\n      // swap the fixedTo listeners\n      this._manageFixedToListener(this.props.fixedTo, false);\n      this._manageFixedToListener(fixedTo, true);\n    } else if (childStyle !== React.Children.only(this.props.children).props.style) {\n      // Re-merge styles... This is only required if all the others fail since all the other\n      // logic always merges styles with the children styles\n      this.setState({ styles: _extends({}, this.state.styles, childStyle) });\n    }\n  };\n\n  Layover.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var _this3 = this;\n\n    var _props2 = this.props,\n        visible = _props2.visible,\n        closeOnOutsideClick = _props2.closeOnOutsideClick;\n\n    var enabled = visible && closeOnOutsideClick;\n    var prevEnabled = prevProps.visible && prevProps.closeOnOutsideClick;\n    if (enabled !== prevEnabled) {\n      if (this._clickTimeout) {\n        clearTimeout(this._clickTimeout);\n        this._clickTimeout = null;\n      }\n\n      // This is really an arbitrary timeout time, but firefox needs to have a timeout\n      // so the context menu doesn't close automatically due to an \"outside click\" being\n      // triggered\n      this._clickTimeout = setTimeout(function () {\n        _this3._clickTimeout = null;\n        handleWindowClickListeners(_this3._handleOutsideClick, enabled);\n      }, enabled ? 300 : 0);\n    }\n  };\n\n  Layover.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this._clickTimeout) {\n      clearTimeout(this._clickTimeout);\n      this._clickTimeout = null;\n    }\n    handleWindowClickListeners(this._handleOutsideClick, false);\n\n    if (!this.props.simplified) {\n      this._manageFixedToListener(this.props.fixedTo, false);\n      this._manageWindowResizeListener(false);\n    }\n  };\n\n  Layover.prototype._getAnchor = function _getAnchor(_ref) {\n    var anchor = _ref.anchor,\n        belowAnchor = _ref.belowAnchor,\n        animationPosition = _ref.animationPosition;\n\n    return animationPosition === Layover.Positions.BELOW && belowAnchor || anchor;\n  };\n\n  /**\n   * One of the past versions of react-md introduced flex-positioned dialogs that\n   * no longer use a negative transform to center the dialogs. This function is\n   * normally called to update the position by re-adding the negative transform again\n   * back to the fixed element so it can be positioned correctly. So if this is\n   * a flex-positioned dialog, we don't need to do this hack.\n   */\n\n\n  /**\n   * Whew. Ok. So since the fixedTo prop can either be two elements or a single item,\n   * this utility function is used to add/remove the scrolling event listeners for\n   * this prop.\n   *\n   * When the fixedTo prop has a horizontal and/or vertical attribute, the `window`\n   * will be the fallback option. If both the horizontal and vertical attributes are\n   * defined, the `window` still needs to have a scroll listener to make sure it\n   * doesn't go off screen.\n   */\n\n\n  /**\n   * This is just a simple utility function to merge the existing state styles,\n   * any new styles, and the children's styles (with most precedence).\n   */\n\n\n  /**\n   * This initializes the popover with the default styles, and the initial bookkeeping\n   * variables to update while it is open.\n   */\n\n\n  /**\n   * Attempts to fix the child by setting it's location ONLY for the entire\n   * page viewport. I didn't bother attempting to fix it for additional fixedTo\n   * stuff.\n   */\n\n\n  /**\n   * When the child is initially mounted, it will update the styles for centering\n   * the element (if enabled) and then attempt to fix any viewport issues.\n   */\n\n\n  /**\n   * This is the meat of the stuff. Do lots of viewport / container checks to make sure\n   * the element should still be visible. If it is still visible, it will update its\n   * x and y position for the new scroll position.\n   */\n\n\n  /**\n   * Attempts to fix a viewport problem by swapping the positioning. This only does\n   * vertical switching right now.\n   *\n   * @param {Object} vp - The result of the viewport function\n   * @return {boolean} true if the fix was able to be done and successful.\n   */\n\n\n  Layover.prototype.render = function render() {\n    var _props3 = this.props,\n        className = _props3.className,\n        block = _props3.block,\n        toggle = _props3.toggle,\n        visible = _props3.visible,\n        children = _props3.children,\n        fullWidth = _props3.fullWidth,\n        animationPosition = _props3.animationPosition,\n        simplified = _props3.simplified,\n        fillViewportWidth = _props3.fillViewportWidth,\n        fillViewportHeight = _props3.fillViewportHeight,\n        anchor = _props3.anchor,\n        belowAnchor = _props3.belowAnchor,\n        onClose = _props3.onClose,\n        repositionOnScroll = _props3.repositionOnScroll,\n        repositionOnResize = _props3.repositionOnResize,\n        sameWidth = _props3.sameWidth,\n        centered = _props3.centered,\n        fixedTo = _props3.fixedTo,\n        toggleQuery = _props3.toggleQuery,\n        yThreshold = _props3.yThreshold,\n        xThreshold = _props3.xThreshold,\n        onContextMenu = _props3.onContextMenu,\n        preventContextMenu = _props3.preventContextMenu,\n        closeOnOutsideClick = _props3.closeOnOutsideClick,\n        minLeft = _props3.minLeft,\n        minRight = _props3.minRight,\n        minBottom = _props3.minBottom,\n        props = _objectWithoutProperties(_props3, ['className', 'block', 'toggle', 'visible', 'children', 'fullWidth', 'animationPosition', 'simplified', 'fillViewportWidth', 'fillViewportHeight', 'anchor', 'belowAnchor', 'onClose', 'repositionOnScroll', 'repositionOnResize', 'sameWidth', 'centered', 'fixedTo', 'toggleQuery', 'yThreshold', 'xThreshold', 'onContextMenu', 'preventContextMenu', 'closeOnOutsideClick', 'minLeft', 'minRight', 'minBottom']);\n\n    var child = void 0;\n    var childId = void 0;\n    if (visible) {\n      child = React.Children.only(children);\n      if (child.props.id) {\n        childId = child.props.id;\n      } else if (props.id) {\n        childId = props.id + '-layover';\n      }\n\n      child = React.cloneElement(children, {\n        ref: this._fixateChild,\n        id: childId,\n        style: simplified ? child.props.style : this.state.styles,\n        className: cn('md-layover-child md-layover-child--' + animationPosition, {\n          'md-layover-child--simplified': simplified\n        }, child.props.className)\n      });\n    }\n\n    var observer = null;\n    if (!simplified && !fillViewportWidth && !fillViewportHeight) {\n      observer = React.createElement(ResizeObserver, {\n        watchWidth: !fillViewportWidth,\n        watchHeight: !fillViewportHeight,\n        target: this._child,\n        onResize: this._handleResize\n      });\n    }\n\n    return React.createElement(\n      CSSTransitionGroup,\n      _extends({}, props, {\n        className: cn('md-layover', {\n          'md-layover--simplified': simplified,\n          'md-inline-block': !block && !fullWidth,\n          'md-full-width': fullWidth\n        }, className),\n        ref: this._setContainer,\n        'aria-haspopup': true,\n        'aria-owns': childId,\n        'aria-expanded': visible,\n        transitionEnter: props.transitionEnterTimeout !== 0,\n        transitionLeave: props.transitionLeaveTimeout !== 0,\n        onContextMenu: this._handleContextMenu\n      }),\n      observer,\n      toggle,\n      child\n    );\n  };\n\n  return Layover;\n}(PureComponent);\n\nLayover.HorizontalAnchors = HorizontalAnchors;\nLayover.VerticalAnchors = VerticalAnchors;\nLayover.Positions = Positions;\nLayover.propTypes = {\n  /**\n   * A id to give the layover itself. This is generally recommended for accessibility. If the\n   * child does not have an id, the child will automatically be updated to be `${id}-layover`.\n   */\n  id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * An optional style to apply to the layover.\n   */\n  style: PropTypes.object,\n\n  /**\n   * An optional className to apply to the layover.\n   */\n  className: PropTypes.string,\n\n  /**\n   * Boolean if the layover's child is currently visible.\n   */\n  visible: PropTypes.bool.isRequired,\n\n  /**\n   * This should either be a single element or two elements that the layover recalculates\n   * its fixed position when scrolling for horizontal and vertical.\n   *\n   * When it is a single element, it will recalculate for both horizontal and vertical\n   * scrolling. Otherwise, you can specify the element for horizontal scrolling and a\n   * separate element for vertical scrolling. If one is omitted, it will default to `window`.\n   *\n   * If the component is no longer considered to be in view after scrolling, the `onClose`\n   * prop will be called.\n   */\n  fixedTo: fixedToShape.isRequired,\n\n  /**\n   * The renderable item that causes the Layover to become visible. This _should_\n   * most likely be an `element` or `arrayOf(element)`, but anything is allowed.\n   */\n  toggle: PropTypes.node,\n\n  /**\n   * Since the `toggle` prop can be anything, I need a way to be able to find an\n   * element to base all the calculations on. This can either be a string that\n   * gets passed to `layover.querySelector`, a DOM Element, or a function that\n   * returns a DOM Element.\n   */\n  toggleQuery: PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.string]).isRequired,\n\n  /**\n   * A single child that should be fixed to the toggle element.\n   */\n  children: PropTypes.element.isRequired,\n\n  /**\n   * Boolean if the Layover should be displayed as a block instead of as an inline block.\n   */\n  block: PropTypes.bool,\n\n  /**\n   * Boolean if the `children` should be centered horizontally and vertically while keeping\n   * its height in mind as well. This is *only* valid if both the x and y `anchor` targets\n   * are `CENTER`.\n   */\n  centered: PropTypes.bool,\n\n  /**\n   * Boolean if the layover should gain the `md-full-width` class name.\n   */\n  fullWidth: PropTypes.bool,\n\n  /**\n   * Boolean if the width of the children should be updated automatically to be the width\n   * of the toggle element.\n   */\n  sameWidth: PropTypes.bool,\n\n  /**\n   * The minimum value the `left` style can be for the child component. This is really just used\n   * to make sure it doesn't scroll off the left of the page. It can also be used to make\n   * full screen layovers on devices when when the `fillViewportWidth` prop is enabled.\n   *\n   * This can either be a number of pixels or a string for percentages. If this value is a string\n   * **it will always be used over the calculated values** so it is preferred to use a number.\n   *\n   * @see {@link #minRight}\n   * @see {@link #fillViewportWidth}\n   */\n  minLeft: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n\n  /**\n   * The minimum value the `right` style can be for the child component. This is really just used\n   * to make sure it doesn't scroll off the right of the page when the `fillViewportWidth` prop is\n   * enabled.\n   *\n   * This can either be a number of pixels or a string for percentages. If this value is a string\n   * **it will always be used over the calculated values** so it is preferred to use a number.\n   *\n   * @see {@link #minLeft}\n   * @see {@link #fillViewportWidth}\n   */\n  minRight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n\n  /**\n   * The minimum value that can be used for the `bottom` prop when the `fillViewportHeight` prop is enabled.\n   * It is generally recommended to keep this value at `0` to keep it stretched to the bottom of the viewport\n   * or setting it to a small positive number to add some padding.\n   *\n   * This can either be a number of pixels or a string for percentages. If this value is a string\n   * **it will always be used over the calculated values** so it is preferred to use a number.\n   *\n   * @see {@link #fillViewportHeight}\n   */\n  minBottom: PropTypes.number.isRequired,\n\n  /**\n   * Boolean if the layover should make the child fill the entire viewport's width. This will just\n   * style the child element with:\n   *\n   * ```js\n   * childStyle = {\n   *   left: this.props.minLeft,\n   *   right: this.props.minRight,\n   * };\n   * ```\n   *\n   * If you add any additional constraints such as `width` or `max-width`, it will not span the entire viewport's\n   * width. This prop should generally really only be used on mobile devices. Using this prop along with\n   * `fillViewportHeight` for Autocompletes can create great Android mobile searches. See the `fillViewportHeight`\n   * for more information about why it is *only Android*.\n   *\n   * @see {@link #minLeft}\n   * @see {@link #minRight}\n   * @see {@link #fillViewportHeight}\n   */\n  fillViewportWidth: PropTypes.bool,\n\n  /**\n   * Boolean if the layover should fill the height of the viewport from the current calculated `top`. This will just\n   * style the child element with:\n   *\n   * ```js\n   * childStyle = {\n   *   top: currentCalculatedTop,\n   *   bottom: this.props.minBottom,\n   *   maxHeight: 'none',\n   * };\n   * ```\n   *\n   * This is *super* nice on Android devices since it will allow you to create nice toolbar search autocompletes\n   * in your app and the list of items will grow until it reaches the soft keyboard. It isn't as nice on iOS since\n   * iOS does not subtract the soft keyboard from the viewport's size so the list will still extend to the bottom\n   * of the page.\n   *\n   * @see {@link #minBottom}\n   * @see {@link #fillViewportWidth}\n   */\n  fillViewportHeight: PropTypes.bool,\n\n  /**\n   * A function used to hide the visibility of the children when the children are no longer\n   * visible or an element outside of the layover is clicked.\n   */\n  onClose: PropTypes.func.isRequired,\n\n  /**\n   * The component to render the Layover as.\n   */\n  component: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]).isRequired,\n\n  /**\n   * The transition name to use for the children appearing/disappearing.\n   */\n  transitionName: PropTypes.string.isRequired,\n\n  /**\n   * The transition duration for the enter animation. The animation can be disabled by setting\n   * this value to 0.\n   */\n  transitionEnterTimeout: PropTypes.number.isRequired,\n\n  /**\n   * The transition duration for the leave animation. The animation can be disabled by setting\n   * this value to 0.\n   */\n  transitionLeaveTimeout: PropTypes.number.isRequired,\n\n  /**\n   * This is a threshold that is used to calculate if the `children` is still in\n   * view by applying this multiplier to the `children`'s width.\n   */\n  xThreshold: PropTypes.number.isRequired,\n\n  /**\n   * This is a threshold that is used to calculate if the `children` is still in\n   * view by applying this multiplier to the `toggle`'s height.\n   */\n  yThreshold: PropTypes.number.isRequired,\n\n  /**\n   * Boolean if the `children` should be hidden when an element outside\n   * of the `Layout` component has been clicked.\n   */\n  closeOnOutsideClick: PropTypes.bool.isRequired,\n\n  /**\n   * This is how the children get \"anchored\" to the `toggle` element and how the\n   * auto-fix attempts will be made. Right now, the auto fixes will only be handled\n   * on viewport boundaries instead of `fixedTo` boundaries. It was too hard for\n   * first attempt.\n   *\n   * The general behavior will be that an equal-opposite of an anchor will be chosen\n   * when that direction is out of viewport. So for example, the children are out\n   * of viewport for the right of the screen, and the `anchor.x` value is\n   * `Layover.HorizontalPositions.RIGHT`, the children will be swapped to be the `LEFT`\n   * of the `toggle` component now.\n   *\n   * So a full list:\n   * - `LEFT` / `RIGHT`\n   * - `INNER_LEFT` / `INNER_RIGHT`\n   * - `TOP` / `BOTTOM`\n   *\n   * The `CENTER` and `OVERLAP` positions can not be automatically adjusted.\n   *\n   * > To be safe, you should use the enum values for the `x` and `y` values.\n   * @see {@link #VerticalAnchors}\n   * @see {@link #HorizontalAnchors}\n   */\n  anchor: anchorShape.isRequired,\n\n  /**\n   * This is how the children get \"anchored\" when the `animationPositions` is set to `Layover.Positions.BELOW`.\n   * Set this to `null` to continue using the base `anchor` prop instead of switching to this anchor.\n   *\n   * @see {@link #anchor}\n   */\n  belowAnchor: anchorShape,\n\n  /**\n   * This is the position that the children should animate from. It directly ties into\n   * the `$md-layover-child-positions` Sass variable.\n   */\n  animationPosition: positionShape.isRequired,\n\n  /**\n   * If you would like the layover to interact as a context menu, provide this prop. It will\n   * make the children appear relative to the context menu origin automatically.\n   *\n   * @see {@link #preventContextMenu}\n   */\n  onContextMenu: PropTypes.func,\n\n  /**\n   * Boolean if the default behavior of the context menu should be prevented when using the\n   * `onContextMenu` prop.\n   *\n   * @see {@link #onContextMenu}\n   */\n  preventContextMenu: PropTypes.bool,\n\n  /**\n   * Boolean if the layover should attempt to automatically adjust the position of the element to\n   * keep it within the viewport. If this value is set to `false`, the `onClose` prop will be called\n   * instead.\n   */\n  repositionOnScroll: PropTypes.bool,\n\n  /**\n   * Boolean if the layover should attempt to automatically adjust the position of the element to\n   * keep it within the viewport. If this value is set to `false`, the `onClose` prop will be called\n   * instead.\n   */\n  repositionOnResize: PropTypes.bool,\n\n  /**\n   * Boolean if the layover should become \"simplified\". This basically disables all the logic for\n   * keeping the child within the viewport and allows you to manage all the positioning via CSS.\n   *\n   * When this is enabled, it updates the `Layover` to have `position: relative` while the child will\n   * have `position: absolute` which will allow for simple `top`, `right`, `bottom`, and/or `left` CSS\n   * to position as wanted.\n   *\n   * This is really only helpful in cases where the layover can't calculate things correctly due to\n   * being in fixed containers somewhere in the page or some other weird stuff. Hopefully this won't\n   * really need to be used much.\n   */\n  simplified: PropTypes.bool\n};\nLayover.defaultProps = {\n  anchor: {\n    x: Layover.HorizontalAnchors.INNER_LEFT,\n    y: Layover.VerticalAnchors.OVERLAP\n  },\n  belowAnchor: {\n    x: Layover.HorizontalAnchors.CENTER,\n    y: Layover.VerticalAnchors.BOTTOM\n  },\n  animationPosition: Layover.Positions.BELOW,\n  repositionOnScroll: true,\n  repositionOnResize: false,\n  component: 'div',\n  fixedTo: typeof window !== 'undefined' ? window : {},\n  toggleQuery: '.md-text-field-container,button,*[role=\"button\"],*[role=\"listbox\"]',\n  transitionName: 'md-layover',\n  transitionEnterTimeout: 200,\n  transitionLeaveTimeout: 200,\n  yThreshold: 0.38,\n  xThreshold: 0.38,\n  closeOnOutsideClick: true,\n  preventContextMenu: true,\n  simplified: false,\n  minLeft: 0,\n  minRight: 0,\n  minBottom: 0,\n  fillViewportWidth: false,\n  fillViewportHeight: false\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this4 = this;\n\n  this._isCenteredDialog = function () {\n    return _this4._dialog && _this4._dialog.classList.contains('md-dialog--centered') && window.getComputedStyle(_this4._dialog).transform !== 'none';\n  };\n\n  this._createStyles = function (anchor, centered, child, rect) {\n    var x = anchor.x,\n        y = anchor.y;\n    var offsetWidth = child.offsetWidth,\n        offsetHeight = child.offsetHeight;\n\n\n    var left = void 0;\n    var top = void 0;\n    if (x === HorizontalAnchors.CENTER) {\n      left = rect.left + rect.width / 2 - offsetWidth / 2;\n    } else if (x === HorizontalAnchors.INNER_RIGHT) {\n      left = rect.right - offsetWidth;\n    } else if (x === HorizontalAnchors.LEFT) {\n      left = rect.left - offsetWidth;\n    } else if (x === HorizontalAnchors.RIGHT) {\n      left = rect.right;\n    }\n\n    if (centered && x === HorizontalAnchors.CENTER && y === VerticalAnchors.CENTER) {\n      top = rect.top - offsetHeight / 2 + rect.height / 2;\n    } else if (y === VerticalAnchors.TOP) {\n      top = rect.top - offsetHeight;\n    } else if (y === VerticalAnchors.CENTER) {\n      top = rect.top + rect.height / 2;\n    } else if (y === VerticalAnchors.BOTTOM) {\n      top = rect.bottom;\n    }\n\n    if (_this4._isCenteredDialog()) {\n      var dialogRect = _this4._dialog.getBoundingClientRect();\n      left -= dialogRect.left;\n      top -= dialogRect.top;\n    }\n\n    var style = {};\n    if (top) {\n      style.top = top;\n    }\n\n    if (left) {\n      style.left = left;\n    }\n\n    return style;\n  };\n\n  this._manageFixedToListener = function (fixedTo, add) {\n    var listener = (add ? 'add' : 'remove') + 'EventListener';\n    if (fixedTo !== window && (fixedTo.x || fixedTo.y)) {\n      var x = fixedTo.x,\n          y = fixedTo.y;\n\n      if (x) {\n        x[listener]('scroll', _this4._handleScroll);\n      } else {\n        window[listener]('scroll', _this4._handleScroll);\n      }\n\n      if (y) {\n        y[listener]('scroll', _this4._handleScroll);\n      } else if (!x) {\n        // Only add the window event listener once\n        window[listener]('scroll', _this4._handleScroll);\n      }\n\n      if (y && y !== window && x && x !== window) {\n        window[listener]('scroll', _this4._handleScroll);\n      }\n    } else {\n      fixedTo[listener]('scroll', _this4._handleScroll);\n\n      if (fixedTo !== window) {\n        window[listener]('scroll', _this4._handleScroll);\n      }\n    }\n  };\n\n  this._manageWindowResizeListener = function (enabled) {\n    if (_this4._windowResizeTimeout) {\n      clearTimeout(_this4._windowResizeTimeout);\n      _this4._windowResizeTimeout = null;\n    }\n\n    if (enabled) {\n      // add a 2 second delay before watching resize events since Android soft keyboards trigger a resize event.\n      _this4._windowResizeTimeout = setTimeout(function () {\n        _this4._windowResizeTimeout = null;\n        window.addEventListener('resize', _this4._handleWindowResize);\n      }, 2000);\n    } else {\n      window.removeEventListener('resize', _this4._handleWindowResize);\n    }\n  };\n\n  this._mergeStyles = function (style) {\n    var _props4 = _this4.props,\n        minLeft = _props4.minLeft,\n        minRight = _props4.minRight,\n        minBottom = _props4.minBottom,\n        fillViewportWidth = _props4.fillViewportWidth,\n        fillViewportHeight = _props4.fillViewportHeight;\n\n    if (fillViewportWidth) {\n      style.left = minLeft;\n      style.right = minRight;\n    } else {\n      if (style.left) {\n        style.left = Math.max(minLeft, style.left);\n      }\n\n      if (style.right) {\n        style.right = Math.max(minRight, style.right);\n      }\n    }\n\n    if (fillViewportHeight) {\n      style.bottom = minBottom;\n      style.maxHeight = 'none';\n    } else {\n      // These styles are only created when filling the viewport height, so clear\n      // them out again\n      style.bottom = null;\n      style.maxHeight = null;\n    }\n\n    return _extends({}, _this4.state.styles, style, React.Children.only(_this4.props.children).props.style);\n  };\n\n  this._init = function (fixedTo, anchor, sameWidth, centered, rect) {\n    if (_this4._child) {\n      // The init function can be called again if the user quickly toggles the layover. If that\n      // is the case, we want the styles that were set after the _positionChild _attemptFix.\n      return;\n    }\n\n    var height = rect.height,\n        width = rect.width;\n    var top = rect.top,\n        left = rect.left,\n        right = rect.right;\n\n    var x = void 0;\n    var y = void 0;\n    if (_this4._dialog) {\n      var scroll = getScroll(_this4._dialog);\n      x = scroll.x;\n      y = scroll.y;\n\n      if (_this4._isCenteredDialog()) {\n        var dialogRect = _this4._dialog.getBoundingClientRect();\n        left -= dialogRect.left;\n        top -= dialogRect.top;\n        right -= dialogRect.right;\n      }\n    } else if (fixedTo !== window && (fixedTo.y || fixedTo.x)) {\n      x = getScroll(fixedTo.x || window).x;\n      y = getScroll(fixedTo.y || window).y;\n    } else {\n      var _scroll = getScroll(fixedTo);\n      x = _scroll.x;\n      y = _scroll.y;\n    }\n\n    _this4._initialX = x;\n    _this4._initialY = y;\n    _this4._initialLeft = left;\n    _this4._initialTop = top;\n\n    if (anchor.x === HorizontalAnchors.INNER_RIGHT) {\n      _this4._initialLeft = left + width;\n    } else if (anchor.x === HorizontalAnchors.RIGHT) {\n      _this4._initialLeft = right;\n    }\n\n    if (!centered) {\n      _this4._lastYFix = anchor.y === VerticalAnchors.TOP ? 'bottom' : 'top';\n    } else {\n      // Centered is not fixable\n      _this4._lastYFix = null;\n    }\n    if (anchor.x === HorizontalAnchors.LEFT || anchor.x === HorizontalAnchors.INNER_LEFT) {\n      _this4._lastXFix = 'right';\n    } else if (anchor.x === HorizontalAnchors.RIGHT || anchor.x === HorizontalAnchors.INNER_RIGHT) {\n      _this4._lastXFix = 'left';\n    } else {\n      // Can't fix others\n      _this4._lastXFix = null;\n    }\n\n    if (anchor.y === VerticalAnchors.BOTTOM) {\n      _this4._initialTop = top + height;\n    }\n\n    if (fixedTo !== window && !fixedTo.y && !fixedTo.x) {\n      var _scroll2 = getScroll(window);\n      _this4._initialWinX = _scroll2.x;\n      _this4._initialWinY = _scroll2.y;\n    }\n\n    var styles = _this4._mergeStyles({\n      left: _this4._initialLeft,\n      top: _this4._initialTop,\n      transformOrigin: undefined,\n      width: sameWidth ? width : undefined\n    });\n\n    _this4.setState({ styles: styles });\n  };\n\n  this._reset = function () {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this4.props,\n        fixedTo = _ref2.fixedTo;\n\n    // Reset all the bookkeeping variables for a fresh start on re-visible\n    _this4._lastXFix = null;\n    _this4._lastYFix = null;\n    _this4._initialX = null;\n    _this4._initialY = null;\n    _this4._initialTop = null;\n    _this4._initialLeft = null;\n\n    if (!_this4._inFixed) {\n      if (_this4._dialog) {\n        _this4._manageFixedToListener(_this4._dialog, false);\n      }\n\n      _this4._manageFixedToListener(fixedTo, false);\n    }\n  };\n\n  this._setContainer = function (container) {\n    _this4._container = findDOMNode(container);\n    _this4._toggle = null;\n    if (!_this4._container) {\n      return;\n    }\n\n    var _props5 = _this4.props,\n        toggleQuery = _props5.toggleQuery,\n        onContextMenu = _props5.onContextMenu;\n\n    if (typeof toggleQuery === 'function') {\n      _this4._toggle = toggleQuery();\n    } else if (typeof toggleQuery === 'string') {\n      _this4._toggle = _this4._container.querySelector(toggleQuery);\n    } else {\n      _this4._toggle = toggleQuery;\n    }\n\n    if (!_this4._toggle && !onContextMenu && process.env.NODE_ENV !== 'production') {\n      var error = new Error('Unable to find a toggle component with the provided `toggleQuery` and `toggle` element. \\n' + ('`toggleQuery`: `' + toggleQuery + '`'));\n      error.toggleQuery = toggleQuery;\n      error.toggle = _this4.props.toggle;\n\n      throw error;\n    }\n\n    var node = _this4._container;\n    while (node && node !== document) {\n      var fixed = window.getComputedStyle(node).position === 'fixed';\n      if (fixed && node.className.match(/md-dialog--(full-page|centered)/)) {\n        _this4._dialog = node;\n        return;\n      } else if (fixed && !node.classList.contains('md-layover-child')) {\n        _this4._inFixed = true;\n        return;\n      }\n\n      node = node.offsetParent || node.parentNode;\n    }\n  };\n\n  this._initialFix = function () {\n    // Need to make a clone that disables any transitions to calculate positioning stuff\n    var clone = _this4._child.cloneNode(true);\n    clone.style.webkitTransform = 'none';\n    clone.style.transfrom = 'none';\n    clone.style.webkitTransition = 'none';\n    clone.style.transition = 'none';\n\n    _this4._child.parentNode.appendChild(clone);\n    var vp = viewport(clone);\n    var childHeight = clone.offsetHeight,\n        childWidth = clone.offsetWidth;\n\n    _this4._child.parentNode.removeChild(clone);\n\n    if (vp === true || !_this4._toggle || !_this4._child) {\n      return;\n    }\n\n    var _getAnchor2 = _this4._getAnchor(_this4.props),\n        x = _getAnchor2.x,\n        y = _getAnchor2.y;\n\n    var toggleHeight = void 0;\n    var toggleWidth = void 0;\n    if (_this4._contextRect) {\n      toggleHeight = _this4._contextRect.height;\n      toggleWidth = _this4._contextRect.width;\n    } else {\n      toggleHeight = _this4._toggle.offsetHeight;\n      toggleWidth = _this4._toggle.offsetWidth;\n    }\n\n    var addToTop = 0;\n    var addToLeft = 0;\n\n    // Android devices will never get this far because they consider the keyboard as part\n    // of the viewport, iOS will and cause it to be a giant negative number. *sigh*\n    // Prevent any additional vertical positioning for iOS\n    if (!_this4.props.fillViewportHeight && (!vp.top || !vp.bottom)) {\n      var multiplier = vp.top ? -1 : 1;\n      if (!vp.bottom && y === VerticalAnchors.OVERLAP) {\n        addToTop += toggleHeight;\n      } else if (y === VerticalAnchors.TOP || y === VerticalAnchors.BOTTOM) {\n        addToTop += multiplier * toggleHeight;\n      }\n\n      addToTop += multiplier * childHeight;\n\n      _this4._lastYFix = vp.top ? 'bottom' : 'top';\n    }\n\n    if (!_this4.props.fillViewportWidth && x !== HorizontalAnchors.CENTER && (!vp.left || !vp.right)) {\n      if (!vp.left && x === HorizontalAnchors.LEFT) {\n        addToLeft += toggleWidth + childWidth;\n        _this4._lastXFix = 'left';\n      } else if (!vp.left && x === HorizontalAnchors.INNER_LEFT) {\n        addToLeft += toggleWidth;\n        _this4._lastXFix = 'left';\n      } else if (!vp.right && x === HorizontalAnchors.RIGHT) {\n        addToLeft -= toggleWidth + childWidth;\n        _this4._lastXFix = 'right';\n      } else if (!vp.right && x === HorizontalAnchors.INNER_RIGHT) {\n        addToLeft -= toggleWidth;\n        _this4._lastXFix = 'right';\n      }\n    }\n\n    if (addToTop !== 0 || addToLeft !== 0) {\n      _this4._initialTop += addToTop;\n      _this4._initialLeft += addToLeft;\n\n      _this4.setState({ styles: _this4._mergeStyles({ top: _this4._initialTop, left: _this4._initialLeft }) });\n    }\n  };\n\n  this._fixateChild = function (child) {\n    _this4._child = findDOMNode(child);\n\n    if (_this4._child !== null) {\n      _this4._childComponent = React.Children.only(_this4.props.children);\n\n      // If child also has a ref callback, simulate the same thing\n      if (typeof _this4._childComponent.ref === 'function') {\n        _this4._childComponent.ref(child);\n      }\n\n      if (_this4.props.simplified || !_this4._child || !_this4._toggle && !_this4._contextRect) {\n        return;\n      }\n\n      _this4._manageWindowResizeListener(true);\n      _this4._positionChild();\n    } else if (_this4._childComponent && typeof _this4._childComponent.ref === 'function') {\n      _this4._childComponent.ref(child);\n    }\n  };\n\n  this._positionChild = function () {\n    var centered = _this4.props.centered;\n\n    var anchor = _this4._getAnchor(_this4.props);\n    var rect = _this4._contextRect || _this4._toggle.getBoundingClientRect();\n    _this4._height = rect.height;\n    _this4._width = rect.width;\n    var styles = _this4._createStyles(anchor, centered, _this4._child, rect);\n    if (styles.top || styles.left) {\n      _this4._initialLeft = styles.left || _this4._initialLeft;\n      _this4._initialTop = styles.top || _this4._initialTop;\n      _this4.setState({ styles: _this4._mergeStyles(styles) }, _this4._initialFix);\n    } else {\n      _this4._initialFix();\n    }\n  };\n\n  this._handleResize = function () {\n    if (_this4.props.visible) {\n      _this4._positionChild();\n    }\n  };\n\n  this._handleScroll = function (e) {\n    if (!_this4.props.repositionOnScroll) {\n      _this4._manageFixedToListener(_this4.props.fixedTo, false);\n      _this4.props.onClose(e);\n    }\n\n    if (!_this4._ticking) {\n      requestAnimationFrame(function () {\n        return _this4._handleTick(e);\n      });\n    }\n\n    _this4._ticking = true;\n  };\n\n  this._handleTick = function (e) {\n    var _props6 = _this4.props,\n        fixedTo = _props6.fixedTo,\n        xThreshold = _props6.xThreshold,\n        yThreshold = _props6.yThreshold;\n\n    var vp = viewport(_this4._child);\n    if (vp !== true && vp.left && vp.right) {\n      var fixed = !_this4._contextRect && _this4._attemptFix(vp);\n      if (!fixed) {\n        _this4.props.onClose(e);\n        _this4._ticking = false;\n      }\n\n      return;\n    } else if (isOutOfBounds(fixedTo, _this4._child, _this4._toggle, yThreshold, xThreshold)) {\n      _this4.props.onClose(e);\n      _this4._ticking = false;\n      return;\n    }\n\n    var x = void 0;\n    var y = void 0;\n    if (_this4._dialog) {\n      var scroll = getScroll(_this4._dialog);\n      x = scroll.x;\n      y = scroll.y;\n    } else if (fixedTo !== window && (fixedTo.x || fixedTo.y)) {\n      x = getScroll(fixedTo.x || window).x;\n      y = getScroll(fixedTo.y || window).y;\n    } else {\n      var _scroll3 = getScroll(fixedTo);\n      x = _scroll3.x;\n      y = _scroll3.y;\n    }\n\n    var winX = void 0;\n    var winY = void 0;\n    // When using the additional fixedTo stuff, need to also keep track of the entire\n    // window's scrolling..\n    if (fixedTo !== window && !fixedTo.x && !fixedTo.y) {\n      var _scroll4 = getScroll(window);\n      winX = _scroll4.x;\n      winY = _scroll4.y;\n    }\n\n    var styles = _this4.state.styles;\n    var left = styles.left,\n        top = styles.top;\n\n    if (_this4._initialX !== x) {\n      left = _this4._initialX - x + _this4._initialLeft;\n    }\n\n    if (winX && _this4._initialWinX !== winX) {\n      left = _this4._initialWinX - winX + _this4._initialX;\n    }\n\n    if (_this4._initialY !== y) {\n      top = _this4._initialY - y + _this4._initialTop;\n    }\n\n    if (winY && _this4._initialWinY !== winY) {\n      top = _this4._initialWinY - winY + _this4._initialTop + (_this4._initialY - y);\n    }\n\n    if (styles.top !== top || styles.left !== left) {\n      _this4.setState({ styles: _this4._mergeStyles({ left: left, top: top }) }, function () {\n        _this4._ticking = false;\n      });\n    } else {\n      _this4._ticking = false;\n    }\n  };\n\n  this._handleOutsideClick = function (e) {\n    if (_this4._contextRect && _this4._child && !_this4._child.contains(e.target) || _this4._container && !_this4._container.contains(e.target)) {\n      _this4.props.onClose(e);\n    }\n  };\n\n  this._handleWindowResize = function (e) {\n    var _props7 = _this4.props,\n        onClose = _props7.onClose,\n        repositionOnResize = _props7.repositionOnResize;\n\n    if (repositionOnResize) {\n      _this4._handleResize();\n    } else {\n      onClose(e);\n      _this4._manageWindowResizeListener(false);\n    }\n  };\n\n  this._attemptFix = function (vp) {\n    var _getAnchor3 = _this4._getAnchor(_this4.props),\n        x = _getAnchor3.x,\n        y = _getAnchor3.y;\n\n    var centered = x === HorizontalAnchors.CENTER && y === VerticalAnchors.CENTER && _this4.props.centered;\n    if (centered || _this4._lastYFix === 'top' && !vp.top || _this4._lastYFix === 'bottom' && !vp.bottom) {\n      return false;\n    }\n\n    var toggleTop = _this4._toggle.getBoundingClientRect().top;\n    var toggleHeight = _this4._toggle.offsetHeight;\n    var childHeight = _this4._child.offsetHeight;\n\n    // Can;t fix if the child can't fit on the page based on the toggle's position\n\n    if (toggleTop + toggleHeight + childHeight > window.innerHeight) {\n      return false;\n    }\n\n    var _child$getBoundingCli = _this4._child.getBoundingClientRect(),\n        top = _child$getBoundingCli.top;\n\n    var newTop = _this4._initialTop;\n    var addToTop = childHeight * (vp.top ? -1 : 1);\n    if (y === VerticalAnchors.OVERLAP) {\n      addToTop += (vp.top ? 1 : -1) * toggleHeight;\n    } else if (y === VerticalAnchors.TOP || y === VerticalAnchors.BOTTOM) {\n      addToTop += (_this4._lastYFix === 'top' ? -1 : 1) * toggleHeight;\n    }\n\n    if (addToTop !== 0) {\n      newTop = top + addToTop;\n      _this4._lastYFix = vp.top ? 'bottom' : 'top';\n    }\n\n    if (newTop !== _this4._initialTop) {\n      _this4._initialTop = newTop;\n      var fixedTo = _this4.props.fixedTo;\n\n      var scrollEl = fixedTo;\n      if (fixedTo !== window && (fixedTo.y || fixedTo.x)) {\n        scrollEl = fixedTo.y || window;\n      }\n\n      _this4._initialY = getScroll(scrollEl).y;\n\n      _this4.setState({ styles: _this4._mergeStyles({ top: _this4._initialTop }) }, function () {\n        _this4._ticking = false;\n      });\n      return true;\n    }\n\n    return false;\n  };\n\n  this._handleContextMenu = function (e) {\n    var anchor = _this4._getAnchor(_this4.props);\n    var _props8 = _this4.props,\n        onContextMenu = _props8.onContextMenu,\n        preventContextMenu = _props8.preventContextMenu,\n        fixedTo = _props8.fixedTo,\n        sameWidth = _props8.sameWidth,\n        centered = _props8.centered,\n        visible = _props8.visible;\n\n    if (!onContextMenu) {\n      return;\n    }\n\n    _this4._contextRect = getSelectedTextPosition(e);\n    if (preventContextMenu && (!_this4._child || !_this4._child.contains(e.target))) {\n      e.preventDefault();\n    }\n\n    onContextMenu(e);\n    if (visible) {\n      _this4._init(fixedTo, anchor, sameWidth, centered, _this4._contextRect);\n    }\n  };\n};\n\nexport default Layover;"]},"metadata":{},"sourceType":"module"}