{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React, { PureComponent, cloneElement, Children, isValidElement } from 'react';\nimport PropTypes from 'prop-types';\nimport { findDOMNode } from 'react-dom';\nimport cn from 'classnames';\nimport { TAB } from '../constants/keyCodes';\nimport handleWindowClickListeners from '../utils/EventUtils/handleWindowClickListeners';\nimport ResizeObserver from '../Helpers/ResizeObserver';\n/**\n * The `ExpansionList` component is a wrapper for the `ExpansionPanel` that helps\n * determine which `ExpansionPanel` currently has tab focus and adjusts the column\n * sizes in the header of the `ExpansionPanel`.\n *\n * The `ExpansionList` and `ExpansionPanel` components should have probably been\n * implemented as a `table` instead of a `ul || ol` since it is more column based,\n * but it would complicate the API to have dynamic row generation for the expanded\n * panels. The expanded panels _might_ not follow the same column widths as their labels\n * so a singular row with a div for expanded content might not work correctly.\n */\n\nvar ExpansionList = function (_PureComponent) {\n  _inherits(ExpansionList, _PureComponent);\n\n  function ExpansionList() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, ExpansionList);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = {\n      columnWidths: [],\n      focusedIndex: -1,\n      overflown: false\n    }, _this._setContainer = function (container) {\n      if (container !== null) {\n        _this._container = findDOMNode(container);\n        window.addEventListener('keyup', _this._determineTabFocus);\n        _this._width = _this._container.offsetWidth;\n\n        _this._calcColumnWidths();\n      }\n    }, _this._determineTabFocus = function (e) {\n      if ((e.which || e.keyCode) === TAB) {\n        var panels = Array.prototype.slice.call(findDOMNode(_this).querySelectorAll('.md-panel-header'));\n\n        _this.setState({\n          focusedIndex: panels.indexOf(e.target)\n        });\n      }\n    }, _this._removeFocus = function () {\n      _this.setState({\n        focusedIndex: -1\n      });\n    }, _this._isOverflown = function (widths) {\n      if (!_this._container) {\n        return false;\n      }\n\n      var panel = _this._container.querySelector('.md-panel-header');\n\n      if (!panel) {\n        return false;\n      }\n\n      var collapser = _this._container.querySelector('.md-expansion-panel__collapser');\n\n      var collapserWidth = collapser ? collapser.offsetWidth : 0;\n      var styles = window.getComputedStyle(panel);\n      var maxWidth = panel.offsetWidth - parseFloat(styles.paddingLeft) - parseFloat(styles.paddingRight) - collapserWidth;\n      var totalWidth = widths.reduce(function (total, w) {\n        return total + w;\n      }, 0);\n      return totalWidth > maxWidth;\n    }, _this._getColumnWidths = function () {\n      if (!_this._container) {\n        return _this.state.columnWidths;\n      }\n\n      return [].slice.call(_this._container.querySelectorAll('.md-panel-header')).reduce(function (maxes, row) {\n        var columns = row.querySelectorAll('.md-panel-column');\n\n        for (var i = 0; i < columns.length; i++) {\n          var col = columns[i]; // Need to reset the widths if it has already been calculated to get a more accurate measurement.\n\n          var _col$style = col.style,\n              width = _col$style.width,\n              minWidth = _col$style.minWidth;\n          col.style.width = 'auto';\n          col.style.minWidth = 'auto'; // Only need to include the offsetWidth of the column because the child will really\n          // determine the width of the column. Since it has already been defined at this point,\n          // no additional work needs to be done.\n\n          maxes[i] = Math.max(col.offsetWidth, maxes[i] || 0);\n          col.style.width = width;\n          col.style.minWidth = minWidth;\n        }\n\n        return maxes;\n      }, [0]);\n    }, _this._calcColumnWidths = function () {\n      var columnWidths = _this.state.columnWidths;\n\n      var nextWidths = _this._getColumnWidths();\n\n      var overflown = _this._isOverflown(nextWidths);\n\n      if (_this.state.overflown !== overflown || columnWidths.length !== nextWidths.length || nextWidths.some(function (w, i) {\n        return w !== columnWidths[i];\n      })) {\n        _this.setState({\n          columnWidths: nextWidths,\n          overflown: overflown\n        });\n      }\n    }, _this._handleResize = function (_ref) {\n      var width = _ref.width;\n      var recalculateThreshold = _this.props.recalculateThreshold;\n\n      if (_this._width !== width && Math.abs(width - _this._width) >= recalculateThreshold) {\n        _this._width = width;\n\n        _this._calcColumnWidths();\n      }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  ExpansionList.prototype.getChildContext = function getChildContext() {\n    var animateContent = this.props.animateContent;\n    return {\n      animateContent: animateContent\n    };\n  };\n\n  ExpansionList.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (this.props.children !== nextProps.children) {\n      this._calcColumnWidths();\n    }\n  };\n\n  ExpansionList.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var focusedIndex = this.state.focusedIndex;\n\n    if (prevState.focusedIndex === focusedIndex || prevState.focusedIndex > -1 && focusedIndex > -1) {\n      return;\n    }\n\n    handleWindowClickListeners(this._removeFocus, this.state.focusedIndex !== -1);\n  };\n\n  ExpansionList.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this.state.focusedIndex === -1) {\n      handleWindowClickListeners(this._removeFocus, false);\n    }\n\n    window.removeEventListener('keyup', this._determineTabFocus);\n  };\n  /**\n   * Since this should really be rendered as a table, need to calculate the max width for each _column_\n   * on the panel's header and apply that as a min width for the other panels.\n   */\n\n\n  ExpansionList.prototype.render = function render() {\n    var _state = this.state,\n        columnWidths = _state.columnWidths,\n        focusedIndex = _state.focusedIndex,\n        overflown = _state.overflown;\n\n    var _props = this.props,\n        children = _props.children,\n        className = _props.className,\n        Component = _props.component,\n        animateContent = _props.animateContent,\n        recalculateThreshold = _props.recalculateThreshold,\n        props = _objectWithoutProperties(_props, ['children', 'className', 'component', 'animateContent', 'recalculateThreshold']);\n\n    var panels = Children.map(children, function (child, i) {\n      if (!child || !isValidElement(child)) {\n        return child;\n      }\n\n      return cloneElement(child, {\n        key: child.key || i,\n        overflown: overflown,\n        columnWidths: columnWidths,\n        focused: focusedIndex === i\n      });\n    });\n    return React.createElement(Component, _extends({}, props, {\n      ref: this._setContainer,\n      className: cn('md-expansion-panel-list', className)\n    }), React.createElement(ResizeObserver, {\n      watchWidth: true,\n      onResize: this._handleResize\n    }), panels);\n  };\n\n  return ExpansionList;\n}(PureComponent);\n\nExpansionList.propTypes = {\n  /**\n   * An optional style object to apply to the list.\n   */\n  style: PropTypes.object,\n\n  /**\n   * An optional className to apply to the list.\n   */\n  className: PropTypes.string,\n\n  /**\n   * The children should be a list or singular `ExpansionPanel` component\n   * to render with some additional props injected.\n   */\n  children: PropTypes.node,\n\n  /**\n   * The component to render the list as.\n   */\n  component: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]).isRequired,\n\n  /**\n   * Boolean if all the expansion panels in the list should animate when their content's visibility\n   * changes. This is just a quicker way to disable all animations instead of having to toggle it off\n   * on each panel.\n   *\n   * > The default value is really `true` since it gets passed down to the `Collapse` component.\n   */\n  animateContent: PropTypes.bool,\n\n  /**\n   * The threshold that should be used for when the list should recalculate the positioning of all\n   * the columns. This will only compare the difference between updates.\n   * So if the size changes from 80 -> 120 -> 160 -> 140. It will only update on the third resize (160)\n   */\n  recalculateThreshold: PropTypes.number.isRequired\n};\nExpansionList.defaultProps = {\n  component: 'ul',\n  recalculateThreshold: 80\n};\nExpansionList.childContextTypes = {\n  animateContent: PropTypes.bool\n};\nexport default ExpansionList;","map":{"version":3,"sources":["C:/Users/Sky/Desktop/info442/homeowork/node_modules/react-md/es/ExpansionPanels/ExpansionList.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_objectWithoutProperties","obj","keys","indexOf","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","React","PureComponent","cloneElement","Children","isValidElement","PropTypes","findDOMNode","cn","TAB","handleWindowClickListeners","ResizeObserver","ExpansionList","_PureComponent","_temp","_this","_ret","_len","args","Array","_key","apply","concat","state","columnWidths","focusedIndex","overflown","_setContainer","container","_container","window","addEventListener","_determineTabFocus","_width","offsetWidth","_calcColumnWidths","e","which","keyCode","panels","slice","querySelectorAll","setState","_removeFocus","_isOverflown","widths","panel","querySelector","collapser","collapserWidth","styles","getComputedStyle","maxWidth","parseFloat","paddingLeft","paddingRight","totalWidth","reduce","total","w","_getColumnWidths","maxes","row","columns","col","_col$style","style","width","minWidth","Math","max","nextWidths","some","_handleResize","_ref","recalculateThreshold","props","abs","getChildContext","animateContent","componentWillReceiveProps","nextProps","children","componentDidUpdate","prevProps","prevState","componentWillUnmount","removeEventListener","render","_state","_props","className","Component","component","map","child","focused","createElement","ref","watchWidth","onResize","propTypes","object","string","node","oneOfType","func","isRequired","bool","number","defaultProps","childContextTypes"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport React, { PureComponent, cloneElement, Children, isValidElement } from 'react';\nimport PropTypes from 'prop-types';\nimport { findDOMNode } from 'react-dom';\nimport cn from 'classnames';\n\nimport { TAB } from '../constants/keyCodes';\nimport handleWindowClickListeners from '../utils/EventUtils/handleWindowClickListeners';\nimport ResizeObserver from '../Helpers/ResizeObserver';\n\n/**\n * The `ExpansionList` component is a wrapper for the `ExpansionPanel` that helps\n * determine which `ExpansionPanel` currently has tab focus and adjusts the column\n * sizes in the header of the `ExpansionPanel`.\n *\n * The `ExpansionList` and `ExpansionPanel` components should have probably been\n * implemented as a `table` instead of a `ul || ol` since it is more column based,\n * but it would complicate the API to have dynamic row generation for the expanded\n * panels. The expanded panels _might_ not follow the same column widths as their labels\n * so a singular row with a div for expanded content might not work correctly.\n */\n\nvar ExpansionList = function (_PureComponent) {\n  _inherits(ExpansionList, _PureComponent);\n\n  function ExpansionList() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, ExpansionList);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { columnWidths: [], focusedIndex: -1, overflown: false }, _this._setContainer = function (container) {\n      if (container !== null) {\n        _this._container = findDOMNode(container);\n        window.addEventListener('keyup', _this._determineTabFocus);\n\n        _this._width = _this._container.offsetWidth;\n        _this._calcColumnWidths();\n      }\n    }, _this._determineTabFocus = function (e) {\n      if ((e.which || e.keyCode) === TAB) {\n        var panels = Array.prototype.slice.call(findDOMNode(_this).querySelectorAll('.md-panel-header'));\n        _this.setState({ focusedIndex: panels.indexOf(e.target) });\n      }\n    }, _this._removeFocus = function () {\n      _this.setState({ focusedIndex: -1 });\n    }, _this._isOverflown = function (widths) {\n      if (!_this._container) {\n        return false;\n      }\n\n      var panel = _this._container.querySelector('.md-panel-header');\n      if (!panel) {\n        return false;\n      }\n\n      var collapser = _this._container.querySelector('.md-expansion-panel__collapser');\n      var collapserWidth = collapser ? collapser.offsetWidth : 0;\n      var styles = window.getComputedStyle(panel);\n      var maxWidth = panel.offsetWidth - parseFloat(styles.paddingLeft) - parseFloat(styles.paddingRight) - collapserWidth;\n\n      var totalWidth = widths.reduce(function (total, w) {\n        return total + w;\n      }, 0);\n      return totalWidth > maxWidth;\n    }, _this._getColumnWidths = function () {\n      if (!_this._container) {\n        return _this.state.columnWidths;\n      }\n\n      return [].slice.call(_this._container.querySelectorAll('.md-panel-header')).reduce(function (maxes, row) {\n        var columns = row.querySelectorAll('.md-panel-column');\n        for (var i = 0; i < columns.length; i++) {\n          var col = columns[i];\n          // Need to reset the widths if it has already been calculated to get a more accurate measurement.\n          var _col$style = col.style,\n              width = _col$style.width,\n              minWidth = _col$style.minWidth;\n\n          col.style.width = 'auto';\n          col.style.minWidth = 'auto';\n\n          // Only need to include the offsetWidth of the column because the child will really\n          // determine the width of the column. Since it has already been defined at this point,\n          // no additional work needs to be done.\n          maxes[i] = Math.max(col.offsetWidth, maxes[i] || 0);\n          col.style.width = width;\n          col.style.minWidth = minWidth;\n        }\n\n        return maxes;\n      }, [0]);\n    }, _this._calcColumnWidths = function () {\n      var columnWidths = _this.state.columnWidths;\n\n      var nextWidths = _this._getColumnWidths();\n      var overflown = _this._isOverflown(nextWidths);\n      if (_this.state.overflown !== overflown || columnWidths.length !== nextWidths.length || nextWidths.some(function (w, i) {\n        return w !== columnWidths[i];\n      })) {\n        _this.setState({ columnWidths: nextWidths, overflown: overflown });\n      }\n    }, _this._handleResize = function (_ref) {\n      var width = _ref.width;\n      var recalculateThreshold = _this.props.recalculateThreshold;\n\n      if (_this._width !== width && Math.abs(width - _this._width) >= recalculateThreshold) {\n        _this._width = width;\n        _this._calcColumnWidths();\n      }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  ExpansionList.prototype.getChildContext = function getChildContext() {\n    var animateContent = this.props.animateContent;\n\n    return { animateContent: animateContent };\n  };\n\n  ExpansionList.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (this.props.children !== nextProps.children) {\n      this._calcColumnWidths();\n    }\n  };\n\n  ExpansionList.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var focusedIndex = this.state.focusedIndex;\n\n    if (prevState.focusedIndex === focusedIndex || prevState.focusedIndex > -1 && focusedIndex > -1) {\n      return;\n    }\n\n    handleWindowClickListeners(this._removeFocus, this.state.focusedIndex !== -1);\n  };\n\n  ExpansionList.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this.state.focusedIndex === -1) {\n      handleWindowClickListeners(this._removeFocus, false);\n    }\n\n    window.removeEventListener('keyup', this._determineTabFocus);\n  };\n\n  /**\n   * Since this should really be rendered as a table, need to calculate the max width for each _column_\n   * on the panel's header and apply that as a min width for the other panels.\n   */\n\n\n  ExpansionList.prototype.render = function render() {\n    var _state = this.state,\n        columnWidths = _state.columnWidths,\n        focusedIndex = _state.focusedIndex,\n        overflown = _state.overflown;\n\n    var _props = this.props,\n        children = _props.children,\n        className = _props.className,\n        Component = _props.component,\n        animateContent = _props.animateContent,\n        recalculateThreshold = _props.recalculateThreshold,\n        props = _objectWithoutProperties(_props, ['children', 'className', 'component', 'animateContent', 'recalculateThreshold']);\n\n    var panels = Children.map(children, function (child, i) {\n      if (!child || !isValidElement(child)) {\n        return child;\n      }\n\n      return cloneElement(child, {\n        key: child.key || i,\n        overflown: overflown,\n        columnWidths: columnWidths,\n        focused: focusedIndex === i\n      });\n    });\n    return React.createElement(\n      Component,\n      _extends({}, props, {\n        ref: this._setContainer,\n        className: cn('md-expansion-panel-list', className)\n      }),\n      React.createElement(ResizeObserver, { watchWidth: true, onResize: this._handleResize }),\n      panels\n    );\n  };\n\n  return ExpansionList;\n}(PureComponent);\n\nExpansionList.propTypes = {\n  /**\n   * An optional style object to apply to the list.\n   */\n  style: PropTypes.object,\n\n  /**\n   * An optional className to apply to the list.\n   */\n  className: PropTypes.string,\n\n  /**\n   * The children should be a list or singular `ExpansionPanel` component\n   * to render with some additional props injected.\n   */\n  children: PropTypes.node,\n\n  /**\n   * The component to render the list as.\n   */\n  component: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]).isRequired,\n\n  /**\n   * Boolean if all the expansion panels in the list should animate when their content's visibility\n   * changes. This is just a quicker way to disable all animations instead of having to toggle it off\n   * on each panel.\n   *\n   * > The default value is really `true` since it gets passed down to the `Collapse` component.\n   */\n  animateContent: PropTypes.bool,\n\n  /**\n   * The threshold that should be used for when the list should recalculate the positioning of all\n   * the columns. This will only compare the difference between updates.\n   * So if the size changes from 80 -> 120 -> 160 -> 140. It will only update on the third resize (160)\n   */\n  recalculateThreshold: PropTypes.number.isRequired\n};\nExpansionList.defaultProps = {\n  component: 'ul',\n  recalculateThreshold: 80\n};\nExpansionList.childContextTypes = {\n  animateContent: PropTypes.bool\n};\nexport default ExpansionList;"]},"metadata":{},"sourceType":"module"}