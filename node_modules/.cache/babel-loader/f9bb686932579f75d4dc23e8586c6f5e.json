{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport { findDOMNode } from 'react-dom';\nimport cn from 'classnames';\nimport deprecated from 'react-prop-types/lib/deprecated';\nimport { MOBILE_MIN_WIDTH, TABLET_MIN_WIDTH, DESKTOP_MIN_WIDTH } from '../constants/media';\nimport TICK from '../constants/CSSTransitionGroupTick';\nimport getField from '../utils/getField';\nimport mapToListParts from '../utils/mapToListParts';\nimport controlled from '../utils/PropTypes/controlled';\nimport Paper from '../Papers/Paper';\nimport Portal from '../Helpers/Portal';\nimport List from '../Lists/List';\nimport Overlay from './Overlay';\nimport { isTemporary, isPermanent, isMini } from './isType';\nimport DrawerTypes from './DrawerTypes';\nvar oneOfDrawerTypes = PropTypes.oneOf([DrawerTypes.FULL_HEIGHT, DrawerTypes.CLIPPED, DrawerTypes.FLOATING, DrawerTypes.PERSISTENT, DrawerTypes.PERSISTENT_MINI, DrawerTypes.TEMPORARY, DrawerTypes.TEMPORARY_MINI]);\n/**\n * The `Drawer` component is used for having a sliding panel of content or navigation\n * that appears from the side of a screen.\n *\n * If the `Drawer` uses any of the `_MINI` drawer types, you will need to also create another\n * `Drawer` that is not `_MINI`. Transitioning the `width` on mobile devices is very sluggish,\n * and it isn't much more work to create another drawer.\n */\n\nvar Drawer = function (_PureComponent) {\n  _inherits(Drawer, _PureComponent);\n  /**\n   * Determines the current media and returns an object containing matches for `mobile`, `tablet`, `desktop`,\n   * and the current drawer type. This expects a `props` object of the drawer.\n   *\n   * If this is used server side, it will default to only matching mobile.\n   *\n   * @param {Object=} props - The current drawer's prop shape to extract the mobile, tablet,\n   *    and desktop type/min widths. This defaults to the drawer's default props.\n   * @return {Object} an object containing the media matches and the current type to use for the drawer.\n   */\n\n\n  Drawer.getCurrentMedia = function getCurrentMedia() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Drawer.defaultProps;\n    var mobileMinWidth = props.mobileMinWidth,\n        tabletMinWidth = props.tabletMinWidth,\n        desktopMinWidth = props.desktopMinWidth,\n        mobileType = props.mobileType,\n        tabletType = props.tabletType,\n        desktopType = props.desktopType,\n        constantType = props.constantType;\n\n    if (typeof window === 'undefined') {\n      var _type = constantType && props.type ? props.type : mobileType;\n\n      return {\n        mobile: true,\n        tablet: false,\n        desktop: false,\n        type: _type\n      };\n    }\n\n    var mobile = Drawer.matchesMedia(mobileMinWidth, tabletMinWidth - 1);\n    var tablet = Drawer.matchesMedia(tabletMinWidth, desktopMinWidth);\n    var desktop = Drawer.matchesMedia(desktopMinWidth);\n    var type = void 0;\n\n    if (constantType && props.type && isTemporary(props.type)) {\n      type = props.type;\n    } else if (desktop) {\n      type = desktopType;\n    } else if (tablet) {\n      type = tabletType;\n    } else {\n      type = mobileType;\n    }\n\n    return {\n      type: type,\n      mobile: mobile,\n      tablet: tablet,\n      desktop: desktop\n    };\n  };\n  /**\n   * Simply does a `window.matchMedia(query)` where the query gets defined as a min width\n   * and optional max width.\n   *\n   * @param {number} min - The min width for the media query.\n   * @param {number=} max - An optional max width to include for the media query.\n   * @return {boolean} true if the media matches.\n   */\n\n\n  Drawer.matchesMedia = function matchesMedia(min, max) {\n    var media = 'screen and (min-width: ' + min + 'px)';\n\n    if (max) {\n      media += ' and (max-width: ' + max + 'px)';\n    }\n\n    return window.matchMedia(media).matches;\n  };\n\n  function Drawer(props) {\n    _classCallCheck(this, Drawer);\n\n    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));\n\n    _initialiseProps.call(_this);\n\n    var defaultVisible = props.defaultVisible,\n        defaultMedia = props.defaultMedia,\n        overlay = props.overlay;\n    _this.state = {\n      mobile: defaultMedia === 'mobile',\n      tablet: defaultMedia === 'tablet',\n      desktop: defaultMedia === 'desktop',\n      animating: false,\n      overlayActive: false,\n      drawerActive: false\n    };\n\n    if (typeof props.type === 'undefined') {\n      _this.state.type = props[defaultMedia + 'Type'];\n    }\n\n    var type = getField(props, _this.state, 'type');\n    _this._initialFix = true;\n\n    if (typeof props.visible === 'undefined') {\n      var _visible = isPermanent(type) || isMini(type);\n\n      if (!_visible && typeof defaultVisible !== 'undefined') {\n        _visible = defaultVisible;\n      }\n\n      _this.state.visible = _visible;\n    }\n\n    var visible = getField(props, _this.state, 'visible');\n    _this.state.overlayActive = (typeof overlay !== 'undefined' ? overlay : isTemporary(type) && !_this.state.desktop) && visible;\n    _this.state.drawerActive = visible;\n    return _this;\n  }\n\n  Drawer.prototype.componentWillMount = function componentWillMount() {\n    if (typeof window !== 'undefined') {\n      this._updateType(this.props);\n    }\n  };\n\n  Drawer.prototype.componentDidMount = function componentDidMount() {\n    if (!isMini(getField(this.props, this.state, 'type'))) {\n      window.addEventListener('resize', this._updateMedia);\n    }\n  };\n\n  Drawer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var _props = this.props,\n        mobileMinWidth = _props.mobileMinWidth,\n        mobileType = _props.mobileType,\n        tabletMinWidth = _props.tabletMinWidth,\n        tabletType = _props.tabletType,\n        desktopMinWidth = _props.desktopMinWidth,\n        desktopType = _props.desktopType;\n\n    if (nextProps.mobileMinWidth !== mobileMinWidth || nextProps.mobileType !== mobileType || nextProps.tabletMinWidth !== tabletMinWidth || nextProps.tabletType !== tabletType || nextProps.desktopMinWidth !== desktopMinWidth || nextProps.desktopType !== desktopType) {\n      this._updateType(nextProps);\n    }\n\n    var visible = nextProps.visible,\n        transitionDuration = nextProps.transitionDuration,\n        overlay = nextProps.overlay;\n\n    if (this.props.visible === nextProps.visible) {\n      return;\n    }\n\n    var type = getField(nextProps, this.state, 'type');\n\n    this._animate(visible, type, transitionDuration, overlay, this.state.desktop);\n  };\n\n  Drawer.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n\n    if (this._closeTimeout) {\n      clearTimeout(this._closeTimeout);\n    }\n\n    window.removeEventListener('resize', this._updateMedia);\n  };\n\n  Drawer.prototype.render = function render() {\n    var _cn;\n\n    var _state = this.state,\n        overlayActive = _state.overlayActive,\n        drawerActive = _state.drawerActive,\n        animating = _state.animating;\n\n    var _props2 = this.props,\n        id = _props2.id,\n        style = _props2.style,\n        className = _props2.className,\n        navStyle = _props2.navStyle,\n        navClassName = _props2.navClassName,\n        component = _props2.component,\n        navItems = _props2.navItems,\n        header = _props2.header,\n        children = _props2.children,\n        inline = _props2.inline,\n        position = _props2.position,\n        overlay = _props2.overlay,\n        clickableDesktopOverlay = _props2.clickableDesktopOverlay,\n        lastChild = _props2.lastChild,\n        portal = _props2.portal,\n        overlayStyle = _props2.overlayStyle,\n        overlayClassName = _props2.overlayClassName,\n        propType = _props2.type,\n        propVisible = _props2.visible,\n        propRenderNode = _props2.renderNode,\n        propNavItemsId = _props2.navItemsId,\n        propZDepth = _props2.zDepth,\n        constantType = _props2.constantType,\n        defaultVisible = _props2.defaultVisible,\n        defaultMedia = _props2.defaultMedia,\n        mobileType = _props2.mobileType,\n        mobileMinWidth = _props2.mobileMinWidth,\n        tabletType = _props2.tabletType,\n        tabletMinWidth = _props2.tabletMinWidth,\n        desktopType = _props2.desktopType,\n        desktopMinWidth = _props2.desktopMinWidth,\n        transitionDuration = _props2.transitionDuration,\n        onMediaTypeChange = _props2.onMediaTypeChange,\n        onVisibilityChange = _props2.onVisibilityChange,\n        autoclose = _props2.autoclose,\n        autocloseAfterInk = _props2.autocloseAfterInk,\n        onVisibilityToggle = _props2.onVisibilityToggle,\n        closeOnNavItemClick = _props2.closeOnNavItemClick,\n        props = _objectWithoutProperties(_props2, ['id', 'style', 'className', 'navStyle', 'navClassName', 'component', 'navItems', 'header', 'children', 'inline', 'position', 'overlay', 'clickableDesktopOverlay', 'lastChild', 'portal', 'overlayStyle', 'overlayClassName', 'type', 'visible', 'renderNode', 'navItemsId', 'zDepth', 'constantType', 'defaultVisible', 'defaultMedia', 'mobileType', 'mobileMinWidth', 'tabletType', 'tabletMinWidth', 'desktopType', 'desktopMinWidth', 'transitionDuration', 'onMediaTypeChange', 'onVisibilityChange', 'autoclose', 'autocloseAfterInk', 'onVisibilityToggle', 'closeOnNavItemClick']);\n\n    var _props3 = this.props,\n        navItemsId = _props3.navItemsId,\n        zDepth = _props3.zDepth;\n\n    if (!navItemsId && id) {\n      navItemsId = id + '-nav-items';\n    }\n\n    var desktop = this.state.desktop;\n    var renderNode = getField(this.props, this.context, 'renderNode');\n    var type = getField(this.props, this.state, 'type');\n    var visible = getField(this.props, this.state, 'visible');\n    var mini = isMini(type);\n    var temporary = isTemporary(type);\n    var floating = DrawerTypes.FLOATING === type;\n    var permanent = isPermanent(type);\n    var Component = void 0;\n\n    if (component) {\n      Component = component;\n    } else if (navItems) {\n      Component = 'nav';\n    } else {\n      Component = 'aside';\n    }\n\n    var navigation = void 0;\n\n    if (navItems) {\n      navigation = React.createElement(List, {\n        ref: this._setNavigation,\n        key: 'navigation',\n        id: navItemsId,\n        style: navStyle,\n        className: cn('md-list--drawer', {\n          'md-toolbar-relative': mini && !visible,\n          'md-background': floating\n        }, navClassName),\n        onClick: this._handleNavClick\n      }, navItems.map(mapToListParts));\n    }\n\n    if (typeof zDepth === 'undefined') {\n      zDepth = 1;\n\n      if (floating || inline) {\n        zDepth = 0;\n      } else if (!mini && temporary) {\n        zDepth = 5;\n      }\n    }\n\n    var overlayVisible = overlay;\n\n    if (typeof overlayVisible !== 'boolean') {\n      overlayVisible = temporary && !mini && (!desktop || clickableDesktopOverlay) && (animating || visible);\n    }\n\n    var drawer = React.createElement(Paper, _extends({}, props, {\n      id: id,\n      key: 'drawer',\n      component: Component,\n      zDepth: zDepth,\n      raiseOnHover: false,\n      style: style,\n      className: cn('md-drawer', (_cn = {}, _cn['md-drawer--' + position] = !inline, _cn['md-drawer--fixed'] = !inline, _cn['md-drawer--inline'] = inline, _cn['md-drawer--active'] = mini || drawerActive, _cn['md-drawer--mini'] = mini, _cn['md-transition--deceleration'] = !mini && !permanent && visible, _cn['md-transition--acceleration'] = !mini && !permanent && !visible, _cn['md-background'] = inline || floating, _cn['md-background--card'] = !floating && !inline, _cn), className)\n    }), header, navigation, children, React.createElement(Overlay, {\n      style: overlayStyle,\n      className: overlayClassName,\n      active: overlayActive,\n      onClick: this._closeDrawer,\n      visible: overlayVisible,\n      renderNode: renderNode\n    }));\n\n    if (inline || permanent) {\n      return drawer;\n    } else if (!portal) {\n      return mini || animating || visible ? drawer : null;\n    }\n\n    return React.createElement(Portal, {\n      visible: animating || visible,\n      renderNode: renderNode,\n      lastChild: lastChild\n    }, drawer);\n  };\n\n  return Drawer;\n}(PureComponent);\n\nDrawer.DrawerTypes = DrawerTypes;\nDrawer.propTypes = {\n  /**\n   * An optional id to provide to the drawer. This is generally a good idea to provide if\n   * there are any `navItems` defined.\n   *\n   * @see {@link #navItemsId}\n   */\n  id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * An optional id to provide to the navItems list. If this is omitted and the `id` prop is\n   * defined, it will be defaulted to `${id}-nav-items`.\n   */\n  navItemsId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * An optional style to apply.\n   */\n  style: PropTypes.object,\n\n  /**\n   * An optional className to apply.\n   */\n  className: PropTypes.string,\n\n  /**\n   * An optional style to apply to the `List` surrounding the `navItems`.\n   */\n  navStyle: PropTypes.object,\n\n  /**\n   * An optional className to apply to the `List` surrounding the `navItems`.\n   */\n  navClassName: PropTypes.string,\n\n  /**\n   * An optional style to apply to the overlay.\n   */\n  overlayStyle: PropTypes.object,\n\n  /**\n   * An optional className to apply to the overlay.\n   */\n  overlayClassName: PropTypes.string,\n\n  /**\n   * An optional component to render the drawer in. When this prop is undefined, the drawer\n   * will be rendered as a `nav` if the `navItems` prop is defined, otherwise an `aside`.\n   */\n  component: PropTypes.oneOfType([PropTypes.func, PropTypes.element, PropTypes.object]),\n\n  /**\n   * An optional list of navigation items to display in the drawer. This list can either contain\n   * a valid child component for a `List` or an object used to create a `Divider`, `Subheader`,\n   * or `ListItem`.\n   *\n   * - To create a divider in the list, set a `divider` key to `true`. Any other keys will be\n   * passed to the `Divider` component.\n   * - To create a subheader in the list, set the `subheader` key to `true`. Any other keys will\n   * be passed to the `Subheader` component.\n   * - To create a list item, just create an object with any normal `ListItem` props.\n   */\n  navItems: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.element, PropTypes.shape({\n    divider: PropTypes.bool,\n    subheader: PropTypes.bool,\n    primaryText: PropTypes.node\n  })])),\n\n  /**\n   * Boolean if a temporary drawer should close when a nav item is clicked.\n   */\n  autoclose: PropTypes.bool,\n\n  /**\n   * An optional header to display. This _should_ normally be a toolbar.\n   */\n  header: PropTypes.node,\n\n  /**\n   * Any additional children to display after the `header` and `navItems`.\n   */\n  children: PropTypes.node,\n\n  /**\n   * The drawer type to use when the current device matches the mobile\n   * media query.\n   */\n  mobileType: PropTypes.oneOf([Drawer.DrawerTypes.TEMPORARY, Drawer.DrawerTypes.TEMPORARY_MINI]).isRequired,\n\n  /**\n   * The min-width to use for the mobile media query.\n   */\n  mobileMinWidth: PropTypes.number.isRequired,\n\n  /**\n   * The drawer type to use when the current device matches the tablet\n   * media query.\n   */\n  tabletType: oneOfDrawerTypes.isRequired,\n\n  /**\n   * The min-width to use for the tablet media query.\n   */\n  tabletMinWidth: PropTypes.number.isRequired,\n\n  /**\n   * The drawer type to use when the current device matches the desktop media\n   * query.\n   */\n  desktopType: oneOfDrawerTypes.isRequired,\n\n  /**\n   * The min-width for a desktop screen.\n   */\n  desktopMinWidth: PropTypes.number.isRequired,\n\n  /**\n   * An optional type to enforce across all media sizes. Since `mobile` devices are\n   * included, you are required to manually specify when the `type` should be `temporary`.\n   *\n   * When the `type` is not one of the `temporary` types, the `onMediaTypeChange` prop\n   * must be provided.\n   */\n  type: function type(props, propName, component) {\n    for (var _len = arguments.length, others = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      others[_key - 3] = arguments[_key];\n    }\n\n    var type = props[propName];\n\n    if (isTemporary(type)) {\n      return oneOfDrawerTypes.apply(undefined, [props, propName, component].concat(others));\n    }\n\n    var err = oneOfDrawerTypes.apply(undefined, [props, propName, component].concat(others));\n\n    if (!err && typeof type !== 'undefined' && !isMini(type) && typeof props.onMediaTypeChange === 'undefined') {\n      err = new Error('You provided a `' + propName + '` prop to the ' + component + ' without the `onMediaTypeChange` ' + ('handler. The `onMediaTypeChange` prop must be specified when the `' + propName + '` is not ') + 'one of the `temporary` types.');\n    }\n\n    return err;\n  },\n\n  /**\n   * An optional function to call when the drawer's type changes when the screen resizes.\n   * The callback will include the new `type` that should be used for the screen size,\n   * and an object containing the media matches for `mobile`, `tablet`, and `desktop`.\n   *\n   * ```js\n   * this.props.onMediaTypeChange(Drawer.DrawerTypes.TEMPORARY, {\n   *   mobile: true,\n   *   tablet: false,\n   *   desktop: false,\n   * });\n   * ```\n   */\n  onMediaTypeChange: PropTypes.func,\n\n  /**\n   * The default drawer type to display on initial render. The drawer will automatically\n   * adjust itself to the correct media once it has mounted. This prop is really only useful\n   * for server side rendering.\n   */\n  defaultMedia: PropTypes.oneOf(['mobile', 'tablet', 'desktop']).isRequired,\n\n  /**\n   * Boolean if there should be a visible overlay when the drawer is visible. The default behavior\n   * is to only include a visible overlay when the `type` is `TEMPORARY` or `TEMPORARY_MINI` and\n   * the device is not a desktop.\n   *\n   * Definining this variable as `true` or `false` will override any default behavior. This means that\n   * if this is enabled for a full-height drawer, an overlay will still be created.\n   */\n  overlay: PropTypes.bool,\n\n  /**\n   * Boolean if the Portal's functionality of rendering in a separate react tree should be applied\n   * to the drawer. The overlay that appears for temporary type drawers will still appear in the\n   * separate subtree.\n   *\n   * @see {@link Helpers/Portal}\n   */\n  portal: PropTypes.bool,\n\n  /**\n   * An optional DOM Node to render the drawer into. The default is to render as\n   * the first child in the `body`.\n   *\n   * > This prop will not be used when the drawer is of the permanent type or `inline` is specified\n   * since the `Portal` component will not be used.\n   */\n  renderNode: PropTypes.object,\n\n  /**\n   * Boolean if the drawer should be rendered as the last child instead of the first child\n   * in the `renderNode` or `body`.\n   *\n   * > This prop will not be used when the drawer is of the permanent type or `inline` is specified\n   * since the `Portal` component will not be used.\n   */\n  lastChild: PropTypes.bool,\n\n  /**\n   * Boolean if the drawer is visible by default. If this is omitted, the drawer will be visible\n   * if the current drawer type is NOT `Drawer.DrawerTypes.TEMPORARY` or `Drawer.DrawerTypes.TEMPORARY_MINI`.\n   *\n   * This basically means that if you are using the default configuration, a mobile device's drawer\n   * will be hidden while tablets and desktops will be visible.\n   */\n  defaultVisible: PropTypes.bool,\n\n  /**\n   * Boolean if the drawer is visible. This will force the component to define the `onVisibilityChange`\n   * prop as well as manually updating the drawer's visibility.\n   */\n  visible: controlled(PropTypes.bool, 'onVisibilityChange', 'defaultVisible'),\n\n  /**\n   * An optional function to call when the visibility of the drawer is changed. The function will\n   * be called with the new visibility state.\n   *\n   * ```js\n   * onVisibilityChange(!currentlyVisible);\n   * ```\n   */\n  onVisibilityChange: PropTypes.func,\n\n  /**\n   * The drawer's position on the page when it is not `inline`. When the drawer's position is `left`,\n   * the width will be `calc(100vw - 56px)` on mobile devices and `$md-drawer-desktop-width` on desktops.\n   *\n   * When the position is `right`, the width will be `100vw` for mobile devices and scaling to the drawer's\n   * children width on desktops.\n   */\n  position: PropTypes.oneOf(['left', 'right']).isRequired,\n\n  /**\n   * Boolean if the drawer should be displayed inline instead of fixed to the page. When this prop\n   * is enabled, the `position` prop will not be used.\n   */\n  inline: PropTypes.bool,\n\n  /**\n   * The `$md-drawer-transition-time` value from sass.\n   */\n  transitionDuration: PropTypes.number.isRequired,\n\n  /**\n   * Boolean if the temporary drawer's overlay should be created on desktop screens. This is really used so that\n   * the drawer will close when a user clicks anywhere on the page except in the drawer.\n   */\n  clickableDesktopOverlay: PropTypes.bool,\n\n  /**\n   * Boolean if the `autoclose` feature should wait for the ink transition to finish before automatically\n   * closing the drawer. This will add a `300ms` delay. If this is `false`, there will only be a `17ms` delay.\n   *\n   * > The delay is required so that any event listeners will still be correctly invoked when an item is clicked.\n   */\n  autocloseAfterInk: PropTypes.bool,\n\n  /**\n   * Boolean if the `type` prop should be constant across all media sizes. This is only valid if the `type` is\n   * one of the temporary types.\n   *\n   * This will basically mean that when attempting to do a media adjustment, it will use the `type` prop instead of\n   * `mobileType`, `tabletType`, and `desktopType` to determine the next drawer type.\n   */\n  constantType: PropTypes.bool.isRequired,\n\n  /**\n   * An optional zDepth to apply to the drawer. If this is omitted, the value will be set as follows:\n   * - floating || inline = 1\n   * - temporary = 5\n   * - all others = 1\n   *\n   * @see {@link Papers/Paper#zDepth}\n   */\n  zDepth: PropTypes.number,\n  closeOnNavItemClick: deprecated(PropTypes.bool, 'Use `autoclose` instead'),\n  onVisibilityToggle: deprecated(PropTypes.func, 'Use `onVisibilityChange` instead')\n};\nDrawer.defaultProps = {\n  defaultMedia: 'mobile',\n  mobileType: Drawer.DrawerTypes.TEMPORARY,\n  mobileMinWidth: MOBILE_MIN_WIDTH,\n  tabletType: Drawer.DrawerTypes.PERSISTENT,\n  tabletMinWidth: TABLET_MIN_WIDTH,\n  desktopType: Drawer.DrawerTypes.FULL_HEIGHT,\n  desktopMinWidth: DESKTOP_MIN_WIDTH,\n  position: 'left',\n  transitionDuration: 300,\n  autoclose: true,\n  clickableDesktopOverlay: true,\n  constantType: true\n};\nDrawer.contextTypes = {\n  renderNode: PropTypes.object\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this._updateType = function (props) {\n    var onMediaTypeChange = props.onMediaTypeChange,\n        overlay = props.overlay,\n        transitionDuration = props.transitionDuration;\n    var onVisibilityChange = props.onVisibilityToggle || props.onVisibilityChange;\n    var state = Drawer.getCurrentMedia(props);\n    var diffType = getField(props, _this2.state, 'type') !== state.type;\n    var diffMedia = state.mobile !== _this2.state.mobile || state.tablet !== _this2.state.tablet || state.desktop !== _this2.state.desktop;\n\n    if (onMediaTypeChange && (diffType || diffMedia)) {\n      onMediaTypeChange(state.type, {\n        mobile: state.mobile,\n        tablet: state.tablet,\n        desktop: state.desktop\n      });\n    }\n\n    if (diffType) {\n      var visible = isPermanent(state.type);\n\n      if (_this2._initialFix) {\n        if (props.defaultVisible) {\n          visible = props.defaultVisible;\n        } else if (props.visible) {\n          visible = props.visible;\n        }\n      }\n\n      var prevVisible = getField(props, _this2.state, 'visible');\n\n      if (onVisibilityChange && visible !== prevVisible) {\n        onVisibilityChange(visible);\n      }\n\n      if (typeof props.visible === 'undefined') {\n        state.visible = visible;\n\n        _this2._animate(visible, state.type, transitionDuration, overlay, state.desktop);\n      }\n    } else if (_this2._initialFix && diffMedia) {\n      state.overlayActive = (typeof overlay !== 'undefined' ? overlay : isTemporary(state.type) && !state.desktop) && getField(props, _this2.state, 'visible');\n    }\n\n    if (typeof props.type !== 'undefined') {\n      var _state2 = state,\n          type = _state2.type,\n          realState = _objectWithoutProperties(_state2, ['type']); // eslint-disable-line no-unused-vars\n\n\n      state = realState;\n    }\n\n    _this2._initialFix = false;\n\n    _this2.setState(state);\n  };\n\n  this._updateMedia = function () {\n    _this2._updateType(_this2.props);\n  };\n\n  this._animate = function (visible, type, timeout, overlay, desktop) {\n    if (_this2._timeout) {\n      clearTimeout(_this2._timeout);\n    }\n\n    if (visible) {\n      _this2._timeout = setTimeout(function () {\n        _this2._timeout = null;\n\n        _this2.setState({\n          overlayActive: overlay || isTemporary(type) && !desktop,\n          drawerActive: true,\n          animating: true\n        });\n      }, TICK);\n    } else {\n      _this2._timeout = setTimeout(function () {\n        _this2._timeout = null;\n\n        _this2.setState({\n          animating: false\n        });\n      }, timeout);\n\n      _this2.setState({\n        animating: true,\n        overlayActive: false,\n        drawerActive: false\n      });\n    }\n  };\n\n  this._setNavigation = function (navigation) {\n    _this2._navigation = findDOMNode(navigation);\n  };\n\n  this._handleNavClick = function (e) {\n    var _props4 = _this2.props,\n        closeOnNavItemClick = _props4.closeOnNavItemClick,\n        autoclose = _props4.autoclose,\n        autocloseAfterInk = _props4.autocloseAfterInk;\n    var enabled = typeof closeOnNavItemClick !== 'undefined' ? closeOnNavItemClick : autoclose;\n\n    if (!enabled || !isTemporary(getField(_this2.props, _this2.state, 'type'))) {\n      return;\n    }\n\n    var target = e.target;\n\n    while (target && _this2._navigation.contains(target)) {\n      if (target.classList.contains('md-list-tile')) {\n        // Clicked a nav item that has a nested list\n        if (target.getAttribute('aria-expanded') !== null) {\n          return;\n        }\n\n        _this2._closeTimeout = setTimeout(function () {\n          _this2._closeTimeout = null;\n\n          _this2._closeDrawer(e);\n        }, autocloseAfterInk ? 300 : TICK);\n        return;\n      }\n\n      target = target.parentNode;\n    }\n  };\n\n  this._closeDrawer = function () {\n    var _props5 = _this2.props,\n        onVisibilityChange = _props5.onVisibilityChange,\n        onVisibilityToggle = _props5.onVisibilityToggle,\n        transitionDuration = _props5.transitionDuration,\n        overlay = _props5.overlay;\n    var callback = onVisibilityToggle || onVisibilityChange;\n\n    if (callback) {\n      callback(false);\n    }\n\n    if (typeof _this2.props.visible === 'undefined') {\n      _this2.setState({\n        visible: false\n      });\n\n      _this2._animate(false, getField(_this2.props, _this2.state, 'type'), transitionDuration, overlay, _this2.state.desktop);\n    }\n  };\n};\n\nexport default Drawer;","map":{"version":3,"sources":["C:/Users/Sky/Desktop/info442/homeowork/node_modules/react-md/es/Drawers/Drawer.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_objectWithoutProperties","obj","keys","indexOf","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","React","PureComponent","PropTypes","findDOMNode","cn","deprecated","MOBILE_MIN_WIDTH","TABLET_MIN_WIDTH","DESKTOP_MIN_WIDTH","TICK","getField","mapToListParts","controlled","Paper","Portal","List","Overlay","isTemporary","isPermanent","isMini","DrawerTypes","oneOfDrawerTypes","oneOf","FULL_HEIGHT","CLIPPED","FLOATING","PERSISTENT","PERSISTENT_MINI","TEMPORARY","TEMPORARY_MINI","Drawer","_PureComponent","getCurrentMedia","props","undefined","defaultProps","mobileMinWidth","tabletMinWidth","desktopMinWidth","mobileType","tabletType","desktopType","constantType","window","_type","type","mobile","tablet","desktop","matchesMedia","min","max","media","matchMedia","matches","_this","_initialiseProps","defaultVisible","defaultMedia","overlay","state","animating","overlayActive","drawerActive","_initialFix","visible","_visible","componentWillMount","_updateType","componentDidMount","addEventListener","_updateMedia","componentWillReceiveProps","nextProps","_props","transitionDuration","_animate","componentWillUnmount","_timeout","clearTimeout","_closeTimeout","removeEventListener","render","_cn","_state","_props2","id","style","className","navStyle","navClassName","component","navItems","header","children","inline","position","clickableDesktopOverlay","lastChild","portal","overlayStyle","overlayClassName","propType","propVisible","propRenderNode","renderNode","propNavItemsId","navItemsId","propZDepth","zDepth","onMediaTypeChange","onVisibilityChange","autoclose","autocloseAfterInk","onVisibilityToggle","closeOnNavItemClick","_props3","context","mini","temporary","floating","permanent","Component","navigation","createElement","ref","_setNavigation","onClick","_handleNavClick","map","overlayVisible","drawer","raiseOnHover","active","_closeDrawer","propTypes","oneOfType","number","string","object","func","element","arrayOf","shape","divider","bool","subheader","primaryText","node","isRequired","propName","_len","others","Array","_key","apply","concat","err","Error","contextTypes","_this2","diffType","diffMedia","prevVisible","_state2","realState","setState","timeout","setTimeout","_navigation","e","_props4","enabled","contains","classList","getAttribute","parentNode","_props5","callback"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport { findDOMNode } from 'react-dom';\nimport cn from 'classnames';\nimport deprecated from 'react-prop-types/lib/deprecated';\n\nimport { MOBILE_MIN_WIDTH, TABLET_MIN_WIDTH, DESKTOP_MIN_WIDTH } from '../constants/media';\nimport TICK from '../constants/CSSTransitionGroupTick';\nimport getField from '../utils/getField';\nimport mapToListParts from '../utils/mapToListParts';\nimport controlled from '../utils/PropTypes/controlled';\nimport Paper from '../Papers/Paper';\nimport Portal from '../Helpers/Portal';\nimport List from '../Lists/List';\nimport Overlay from './Overlay';\n\nimport { isTemporary, isPermanent, isMini } from './isType';\nimport DrawerTypes from './DrawerTypes';\n\nvar oneOfDrawerTypes = PropTypes.oneOf([DrawerTypes.FULL_HEIGHT, DrawerTypes.CLIPPED, DrawerTypes.FLOATING, DrawerTypes.PERSISTENT, DrawerTypes.PERSISTENT_MINI, DrawerTypes.TEMPORARY, DrawerTypes.TEMPORARY_MINI]);\n\n/**\n * The `Drawer` component is used for having a sliding panel of content or navigation\n * that appears from the side of a screen.\n *\n * If the `Drawer` uses any of the `_MINI` drawer types, you will need to also create another\n * `Drawer` that is not `_MINI`. Transitioning the `width` on mobile devices is very sluggish,\n * and it isn't much more work to create another drawer.\n */\n\nvar Drawer = function (_PureComponent) {\n  _inherits(Drawer, _PureComponent);\n\n  /**\n   * Determines the current media and returns an object containing matches for `mobile`, `tablet`, `desktop`,\n   * and the current drawer type. This expects a `props` object of the drawer.\n   *\n   * If this is used server side, it will default to only matching mobile.\n   *\n   * @param {Object=} props - The current drawer's prop shape to extract the mobile, tablet,\n   *    and desktop type/min widths. This defaults to the drawer's default props.\n   * @return {Object} an object containing the media matches and the current type to use for the drawer.\n   */\n  Drawer.getCurrentMedia = function getCurrentMedia() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Drawer.defaultProps;\n    var mobileMinWidth = props.mobileMinWidth,\n        tabletMinWidth = props.tabletMinWidth,\n        desktopMinWidth = props.desktopMinWidth,\n        mobileType = props.mobileType,\n        tabletType = props.tabletType,\n        desktopType = props.desktopType,\n        constantType = props.constantType;\n\n    if (typeof window === 'undefined') {\n      var _type = constantType && props.type ? props.type : mobileType;\n      return { mobile: true, tablet: false, desktop: false, type: _type };\n    }\n\n    var mobile = Drawer.matchesMedia(mobileMinWidth, tabletMinWidth - 1);\n    var tablet = Drawer.matchesMedia(tabletMinWidth, desktopMinWidth);\n    var desktop = Drawer.matchesMedia(desktopMinWidth);\n\n    var type = void 0;\n    if (constantType && props.type && isTemporary(props.type)) {\n      type = props.type;\n    } else if (desktop) {\n      type = desktopType;\n    } else if (tablet) {\n      type = tabletType;\n    } else {\n      type = mobileType;\n    }\n\n    return { type: type, mobile: mobile, tablet: tablet, desktop: desktop };\n  };\n\n  /**\n   * Simply does a `window.matchMedia(query)` where the query gets defined as a min width\n   * and optional max width.\n   *\n   * @param {number} min - The min width for the media query.\n   * @param {number=} max - An optional max width to include for the media query.\n   * @return {boolean} true if the media matches.\n   */\n\n\n  Drawer.matchesMedia = function matchesMedia(min, max) {\n    var media = 'screen and (min-width: ' + min + 'px)';\n    if (max) {\n      media += ' and (max-width: ' + max + 'px)';\n    }\n\n    return window.matchMedia(media).matches;\n  };\n\n  function Drawer(props) {\n    _classCallCheck(this, Drawer);\n\n    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));\n\n    _initialiseProps.call(_this);\n\n    var defaultVisible = props.defaultVisible,\n        defaultMedia = props.defaultMedia,\n        overlay = props.overlay;\n\n\n    _this.state = {\n      mobile: defaultMedia === 'mobile',\n      tablet: defaultMedia === 'tablet',\n      desktop: defaultMedia === 'desktop',\n      animating: false,\n      overlayActive: false,\n      drawerActive: false\n    };\n\n    if (typeof props.type === 'undefined') {\n      _this.state.type = props[defaultMedia + 'Type'];\n    }\n\n    var type = getField(props, _this.state, 'type');\n    _this._initialFix = true;\n\n    if (typeof props.visible === 'undefined') {\n      var _visible = isPermanent(type) || isMini(type);\n      if (!_visible && typeof defaultVisible !== 'undefined') {\n        _visible = defaultVisible;\n      }\n\n      _this.state.visible = _visible;\n    }\n\n    var visible = getField(props, _this.state, 'visible');\n\n    _this.state.overlayActive = (typeof overlay !== 'undefined' ? overlay : isTemporary(type) && !_this.state.desktop) && visible;\n    _this.state.drawerActive = visible;\n    return _this;\n  }\n\n  Drawer.prototype.componentWillMount = function componentWillMount() {\n    if (typeof window !== 'undefined') {\n      this._updateType(this.props);\n    }\n  };\n\n  Drawer.prototype.componentDidMount = function componentDidMount() {\n    if (!isMini(getField(this.props, this.state, 'type'))) {\n      window.addEventListener('resize', this._updateMedia);\n    }\n  };\n\n  Drawer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var _props = this.props,\n        mobileMinWidth = _props.mobileMinWidth,\n        mobileType = _props.mobileType,\n        tabletMinWidth = _props.tabletMinWidth,\n        tabletType = _props.tabletType,\n        desktopMinWidth = _props.desktopMinWidth,\n        desktopType = _props.desktopType;\n\n\n    if (nextProps.mobileMinWidth !== mobileMinWidth || nextProps.mobileType !== mobileType || nextProps.tabletMinWidth !== tabletMinWidth || nextProps.tabletType !== tabletType || nextProps.desktopMinWidth !== desktopMinWidth || nextProps.desktopType !== desktopType) {\n      this._updateType(nextProps);\n    }\n\n    var visible = nextProps.visible,\n        transitionDuration = nextProps.transitionDuration,\n        overlay = nextProps.overlay;\n\n    if (this.props.visible === nextProps.visible) {\n      return;\n    }\n\n    var type = getField(nextProps, this.state, 'type');\n    this._animate(visible, type, transitionDuration, overlay, this.state.desktop);\n  };\n\n  Drawer.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n\n    if (this._closeTimeout) {\n      clearTimeout(this._closeTimeout);\n    }\n\n    window.removeEventListener('resize', this._updateMedia);\n  };\n\n  Drawer.prototype.render = function render() {\n    var _cn;\n\n    var _state = this.state,\n        overlayActive = _state.overlayActive,\n        drawerActive = _state.drawerActive,\n        animating = _state.animating;\n\n    var _props2 = this.props,\n        id = _props2.id,\n        style = _props2.style,\n        className = _props2.className,\n        navStyle = _props2.navStyle,\n        navClassName = _props2.navClassName,\n        component = _props2.component,\n        navItems = _props2.navItems,\n        header = _props2.header,\n        children = _props2.children,\n        inline = _props2.inline,\n        position = _props2.position,\n        overlay = _props2.overlay,\n        clickableDesktopOverlay = _props2.clickableDesktopOverlay,\n        lastChild = _props2.lastChild,\n        portal = _props2.portal,\n        overlayStyle = _props2.overlayStyle,\n        overlayClassName = _props2.overlayClassName,\n        propType = _props2.type,\n        propVisible = _props2.visible,\n        propRenderNode = _props2.renderNode,\n        propNavItemsId = _props2.navItemsId,\n        propZDepth = _props2.zDepth,\n        constantType = _props2.constantType,\n        defaultVisible = _props2.defaultVisible,\n        defaultMedia = _props2.defaultMedia,\n        mobileType = _props2.mobileType,\n        mobileMinWidth = _props2.mobileMinWidth,\n        tabletType = _props2.tabletType,\n        tabletMinWidth = _props2.tabletMinWidth,\n        desktopType = _props2.desktopType,\n        desktopMinWidth = _props2.desktopMinWidth,\n        transitionDuration = _props2.transitionDuration,\n        onMediaTypeChange = _props2.onMediaTypeChange,\n        onVisibilityChange = _props2.onVisibilityChange,\n        autoclose = _props2.autoclose,\n        autocloseAfterInk = _props2.autocloseAfterInk,\n        onVisibilityToggle = _props2.onVisibilityToggle,\n        closeOnNavItemClick = _props2.closeOnNavItemClick,\n        props = _objectWithoutProperties(_props2, ['id', 'style', 'className', 'navStyle', 'navClassName', 'component', 'navItems', 'header', 'children', 'inline', 'position', 'overlay', 'clickableDesktopOverlay', 'lastChild', 'portal', 'overlayStyle', 'overlayClassName', 'type', 'visible', 'renderNode', 'navItemsId', 'zDepth', 'constantType', 'defaultVisible', 'defaultMedia', 'mobileType', 'mobileMinWidth', 'tabletType', 'tabletMinWidth', 'desktopType', 'desktopMinWidth', 'transitionDuration', 'onMediaTypeChange', 'onVisibilityChange', 'autoclose', 'autocloseAfterInk', 'onVisibilityToggle', 'closeOnNavItemClick']);\n\n    var _props3 = this.props,\n        navItemsId = _props3.navItemsId,\n        zDepth = _props3.zDepth;\n\n    if (!navItemsId && id) {\n      navItemsId = id + '-nav-items';\n    }\n\n    var desktop = this.state.desktop;\n\n    var renderNode = getField(this.props, this.context, 'renderNode');\n    var type = getField(this.props, this.state, 'type');\n    var visible = getField(this.props, this.state, 'visible');\n    var mini = isMini(type);\n    var temporary = isTemporary(type);\n    var floating = DrawerTypes.FLOATING === type;\n    var permanent = isPermanent(type);\n\n    var Component = void 0;\n    if (component) {\n      Component = component;\n    } else if (navItems) {\n      Component = 'nav';\n    } else {\n      Component = 'aside';\n    }\n\n    var navigation = void 0;\n    if (navItems) {\n      navigation = React.createElement(\n        List,\n        {\n          ref: this._setNavigation,\n          key: 'navigation',\n          id: navItemsId,\n          style: navStyle,\n          className: cn('md-list--drawer', {\n            'md-toolbar-relative': mini && !visible,\n            'md-background': floating\n          }, navClassName),\n          onClick: this._handleNavClick\n        },\n        navItems.map(mapToListParts)\n      );\n    }\n\n    if (typeof zDepth === 'undefined') {\n      zDepth = 1;\n      if (floating || inline) {\n        zDepth = 0;\n      } else if (!mini && temporary) {\n        zDepth = 5;\n      }\n    }\n\n    var overlayVisible = overlay;\n    if (typeof overlayVisible !== 'boolean') {\n      overlayVisible = temporary && !mini && (!desktop || clickableDesktopOverlay) && (animating || visible);\n    }\n\n    var drawer = React.createElement(\n      Paper,\n      _extends({}, props, {\n        id: id,\n        key: 'drawer',\n        component: Component,\n        zDepth: zDepth,\n        raiseOnHover: false,\n        style: style,\n        className: cn('md-drawer', (_cn = {}, _cn['md-drawer--' + position] = !inline, _cn['md-drawer--fixed'] = !inline, _cn['md-drawer--inline'] = inline, _cn['md-drawer--active'] = mini || drawerActive, _cn['md-drawer--mini'] = mini, _cn['md-transition--deceleration'] = !mini && !permanent && visible, _cn['md-transition--acceleration'] = !mini && !permanent && !visible, _cn['md-background'] = inline || floating, _cn['md-background--card'] = !floating && !inline, _cn), className)\n      }),\n      header,\n      navigation,\n      children,\n      React.createElement(Overlay, {\n        style: overlayStyle,\n        className: overlayClassName,\n        active: overlayActive,\n        onClick: this._closeDrawer,\n        visible: overlayVisible,\n        renderNode: renderNode\n      })\n    );\n\n    if (inline || permanent) {\n      return drawer;\n    } else if (!portal) {\n      return mini || animating || visible ? drawer : null;\n    }\n\n    return React.createElement(\n      Portal,\n      { visible: animating || visible, renderNode: renderNode, lastChild: lastChild },\n      drawer\n    );\n  };\n\n  return Drawer;\n}(PureComponent);\n\nDrawer.DrawerTypes = DrawerTypes;\nDrawer.propTypes = {\n  /**\n   * An optional id to provide to the drawer. This is generally a good idea to provide if\n   * there are any `navItems` defined.\n   *\n   * @see {@link #navItemsId}\n   */\n  id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * An optional id to provide to the navItems list. If this is omitted and the `id` prop is\n   * defined, it will be defaulted to `${id}-nav-items`.\n   */\n  navItemsId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * An optional style to apply.\n   */\n  style: PropTypes.object,\n\n  /**\n   * An optional className to apply.\n   */\n  className: PropTypes.string,\n\n  /**\n   * An optional style to apply to the `List` surrounding the `navItems`.\n   */\n  navStyle: PropTypes.object,\n\n  /**\n   * An optional className to apply to the `List` surrounding the `navItems`.\n   */\n  navClassName: PropTypes.string,\n\n  /**\n   * An optional style to apply to the overlay.\n   */\n  overlayStyle: PropTypes.object,\n\n  /**\n   * An optional className to apply to the overlay.\n   */\n  overlayClassName: PropTypes.string,\n\n  /**\n   * An optional component to render the drawer in. When this prop is undefined, the drawer\n   * will be rendered as a `nav` if the `navItems` prop is defined, otherwise an `aside`.\n   */\n  component: PropTypes.oneOfType([PropTypes.func, PropTypes.element, PropTypes.object]),\n\n  /**\n   * An optional list of navigation items to display in the drawer. This list can either contain\n   * a valid child component for a `List` or an object used to create a `Divider`, `Subheader`,\n   * or `ListItem`.\n   *\n   * - To create a divider in the list, set a `divider` key to `true`. Any other keys will be\n   * passed to the `Divider` component.\n   * - To create a subheader in the list, set the `subheader` key to `true`. Any other keys will\n   * be passed to the `Subheader` component.\n   * - To create a list item, just create an object with any normal `ListItem` props.\n   */\n  navItems: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.element, PropTypes.shape({\n    divider: PropTypes.bool,\n    subheader: PropTypes.bool,\n    primaryText: PropTypes.node\n  })])),\n\n  /**\n   * Boolean if a temporary drawer should close when a nav item is clicked.\n   */\n  autoclose: PropTypes.bool,\n\n  /**\n   * An optional header to display. This _should_ normally be a toolbar.\n   */\n  header: PropTypes.node,\n\n  /**\n   * Any additional children to display after the `header` and `navItems`.\n   */\n  children: PropTypes.node,\n\n  /**\n   * The drawer type to use when the current device matches the mobile\n   * media query.\n   */\n  mobileType: PropTypes.oneOf([Drawer.DrawerTypes.TEMPORARY, Drawer.DrawerTypes.TEMPORARY_MINI]).isRequired,\n\n  /**\n   * The min-width to use for the mobile media query.\n   */\n  mobileMinWidth: PropTypes.number.isRequired,\n\n  /**\n   * The drawer type to use when the current device matches the tablet\n   * media query.\n   */\n  tabletType: oneOfDrawerTypes.isRequired,\n\n  /**\n   * The min-width to use for the tablet media query.\n   */\n  tabletMinWidth: PropTypes.number.isRequired,\n\n  /**\n   * The drawer type to use when the current device matches the desktop media\n   * query.\n   */\n  desktopType: oneOfDrawerTypes.isRequired,\n\n  /**\n   * The min-width for a desktop screen.\n   */\n  desktopMinWidth: PropTypes.number.isRequired,\n\n  /**\n   * An optional type to enforce across all media sizes. Since `mobile` devices are\n   * included, you are required to manually specify when the `type` should be `temporary`.\n   *\n   * When the `type` is not one of the `temporary` types, the `onMediaTypeChange` prop\n   * must be provided.\n   */\n  type: function type(props, propName, component) {\n    for (var _len = arguments.length, others = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      others[_key - 3] = arguments[_key];\n    }\n\n    var type = props[propName];\n    if (isTemporary(type)) {\n      return oneOfDrawerTypes.apply(undefined, [props, propName, component].concat(others));\n    }\n\n    var err = oneOfDrawerTypes.apply(undefined, [props, propName, component].concat(others));\n    if (!err && typeof type !== 'undefined' && !isMini(type) && typeof props.onMediaTypeChange === 'undefined') {\n      err = new Error('You provided a `' + propName + '` prop to the ' + component + ' without the `onMediaTypeChange` ' + ('handler. The `onMediaTypeChange` prop must be specified when the `' + propName + '` is not ') + 'one of the `temporary` types.');\n    }\n\n    return err;\n  },\n\n  /**\n   * An optional function to call when the drawer's type changes when the screen resizes.\n   * The callback will include the new `type` that should be used for the screen size,\n   * and an object containing the media matches for `mobile`, `tablet`, and `desktop`.\n   *\n   * ```js\n   * this.props.onMediaTypeChange(Drawer.DrawerTypes.TEMPORARY, {\n   *   mobile: true,\n   *   tablet: false,\n   *   desktop: false,\n   * });\n   * ```\n   */\n  onMediaTypeChange: PropTypes.func,\n\n  /**\n   * The default drawer type to display on initial render. The drawer will automatically\n   * adjust itself to the correct media once it has mounted. This prop is really only useful\n   * for server side rendering.\n   */\n  defaultMedia: PropTypes.oneOf(['mobile', 'tablet', 'desktop']).isRequired,\n\n  /**\n   * Boolean if there should be a visible overlay when the drawer is visible. The default behavior\n   * is to only include a visible overlay when the `type` is `TEMPORARY` or `TEMPORARY_MINI` and\n   * the device is not a desktop.\n   *\n   * Definining this variable as `true` or `false` will override any default behavior. This means that\n   * if this is enabled for a full-height drawer, an overlay will still be created.\n   */\n  overlay: PropTypes.bool,\n\n  /**\n   * Boolean if the Portal's functionality of rendering in a separate react tree should be applied\n   * to the drawer. The overlay that appears for temporary type drawers will still appear in the\n   * separate subtree.\n   *\n   * @see {@link Helpers/Portal}\n   */\n  portal: PropTypes.bool,\n\n  /**\n   * An optional DOM Node to render the drawer into. The default is to render as\n   * the first child in the `body`.\n   *\n   * > This prop will not be used when the drawer is of the permanent type or `inline` is specified\n   * since the `Portal` component will not be used.\n   */\n  renderNode: PropTypes.object,\n\n  /**\n   * Boolean if the drawer should be rendered as the last child instead of the first child\n   * in the `renderNode` or `body`.\n   *\n   * > This prop will not be used when the drawer is of the permanent type or `inline` is specified\n   * since the `Portal` component will not be used.\n   */\n  lastChild: PropTypes.bool,\n\n  /**\n   * Boolean if the drawer is visible by default. If this is omitted, the drawer will be visible\n   * if the current drawer type is NOT `Drawer.DrawerTypes.TEMPORARY` or `Drawer.DrawerTypes.TEMPORARY_MINI`.\n   *\n   * This basically means that if you are using the default configuration, a mobile device's drawer\n   * will be hidden while tablets and desktops will be visible.\n   */\n  defaultVisible: PropTypes.bool,\n\n  /**\n   * Boolean if the drawer is visible. This will force the component to define the `onVisibilityChange`\n   * prop as well as manually updating the drawer's visibility.\n   */\n  visible: controlled(PropTypes.bool, 'onVisibilityChange', 'defaultVisible'),\n\n  /**\n   * An optional function to call when the visibility of the drawer is changed. The function will\n   * be called with the new visibility state.\n   *\n   * ```js\n   * onVisibilityChange(!currentlyVisible);\n   * ```\n   */\n  onVisibilityChange: PropTypes.func,\n\n  /**\n   * The drawer's position on the page when it is not `inline`. When the drawer's position is `left`,\n   * the width will be `calc(100vw - 56px)` on mobile devices and `$md-drawer-desktop-width` on desktops.\n   *\n   * When the position is `right`, the width will be `100vw` for mobile devices and scaling to the drawer's\n   * children width on desktops.\n   */\n  position: PropTypes.oneOf(['left', 'right']).isRequired,\n\n  /**\n   * Boolean if the drawer should be displayed inline instead of fixed to the page. When this prop\n   * is enabled, the `position` prop will not be used.\n   */\n  inline: PropTypes.bool,\n\n  /**\n   * The `$md-drawer-transition-time` value from sass.\n   */\n  transitionDuration: PropTypes.number.isRequired,\n\n  /**\n   * Boolean if the temporary drawer's overlay should be created on desktop screens. This is really used so that\n   * the drawer will close when a user clicks anywhere on the page except in the drawer.\n   */\n  clickableDesktopOverlay: PropTypes.bool,\n\n  /**\n   * Boolean if the `autoclose` feature should wait for the ink transition to finish before automatically\n   * closing the drawer. This will add a `300ms` delay. If this is `false`, there will only be a `17ms` delay.\n   *\n   * > The delay is required so that any event listeners will still be correctly invoked when an item is clicked.\n   */\n  autocloseAfterInk: PropTypes.bool,\n\n  /**\n   * Boolean if the `type` prop should be constant across all media sizes. This is only valid if the `type` is\n   * one of the temporary types.\n   *\n   * This will basically mean that when attempting to do a media adjustment, it will use the `type` prop instead of\n   * `mobileType`, `tabletType`, and `desktopType` to determine the next drawer type.\n   */\n  constantType: PropTypes.bool.isRequired,\n\n  /**\n   * An optional zDepth to apply to the drawer. If this is omitted, the value will be set as follows:\n   * - floating || inline = 1\n   * - temporary = 5\n   * - all others = 1\n   *\n   * @see {@link Papers/Paper#zDepth}\n   */\n  zDepth: PropTypes.number,\n\n  closeOnNavItemClick: deprecated(PropTypes.bool, 'Use `autoclose` instead'),\n  onVisibilityToggle: deprecated(PropTypes.func, 'Use `onVisibilityChange` instead')\n};\nDrawer.defaultProps = {\n  defaultMedia: 'mobile',\n  mobileType: Drawer.DrawerTypes.TEMPORARY,\n  mobileMinWidth: MOBILE_MIN_WIDTH,\n  tabletType: Drawer.DrawerTypes.PERSISTENT,\n  tabletMinWidth: TABLET_MIN_WIDTH,\n  desktopType: Drawer.DrawerTypes.FULL_HEIGHT,\n  desktopMinWidth: DESKTOP_MIN_WIDTH,\n  position: 'left',\n  transitionDuration: 300,\n  autoclose: true,\n  clickableDesktopOverlay: true,\n  constantType: true\n};\nDrawer.contextTypes = {\n  renderNode: PropTypes.object\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this._updateType = function (props) {\n    var onMediaTypeChange = props.onMediaTypeChange,\n        overlay = props.overlay,\n        transitionDuration = props.transitionDuration;\n\n\n    var onVisibilityChange = props.onVisibilityToggle || props.onVisibilityChange;\n\n    var state = Drawer.getCurrentMedia(props);\n    var diffType = getField(props, _this2.state, 'type') !== state.type;\n    var diffMedia = state.mobile !== _this2.state.mobile || state.tablet !== _this2.state.tablet || state.desktop !== _this2.state.desktop;\n\n    if (onMediaTypeChange && (diffType || diffMedia)) {\n      onMediaTypeChange(state.type, { mobile: state.mobile, tablet: state.tablet, desktop: state.desktop });\n    }\n\n    if (diffType) {\n      var visible = isPermanent(state.type);\n      if (_this2._initialFix) {\n        if (props.defaultVisible) {\n          visible = props.defaultVisible;\n        } else if (props.visible) {\n          visible = props.visible;\n        }\n      }\n\n      var prevVisible = getField(props, _this2.state, 'visible');\n      if (onVisibilityChange && visible !== prevVisible) {\n        onVisibilityChange(visible);\n      }\n\n      if (typeof props.visible === 'undefined') {\n        state.visible = visible;\n        _this2._animate(visible, state.type, transitionDuration, overlay, state.desktop);\n      }\n    } else if (_this2._initialFix && diffMedia) {\n      state.overlayActive = (typeof overlay !== 'undefined' ? overlay : isTemporary(state.type) && !state.desktop) && getField(props, _this2.state, 'visible');\n    }\n\n    if (typeof props.type !== 'undefined') {\n      var _state2 = state,\n          type = _state2.type,\n          realState = _objectWithoutProperties(_state2, ['type']); // eslint-disable-line no-unused-vars\n\n\n      state = realState;\n    }\n\n    _this2._initialFix = false;\n    _this2.setState(state);\n  };\n\n  this._updateMedia = function () {\n    _this2._updateType(_this2.props);\n  };\n\n  this._animate = function (visible, type, timeout, overlay, desktop) {\n    if (_this2._timeout) {\n      clearTimeout(_this2._timeout);\n    }\n\n    if (visible) {\n      _this2._timeout = setTimeout(function () {\n        _this2._timeout = null;\n\n        _this2.setState({\n          overlayActive: overlay || isTemporary(type) && !desktop,\n          drawerActive: true,\n          animating: true\n        });\n      }, TICK);\n    } else {\n      _this2._timeout = setTimeout(function () {\n        _this2._timeout = null;\n\n        _this2.setState({ animating: false });\n      }, timeout);\n      _this2.setState({ animating: true, overlayActive: false, drawerActive: false });\n    }\n  };\n\n  this._setNavigation = function (navigation) {\n    _this2._navigation = findDOMNode(navigation);\n  };\n\n  this._handleNavClick = function (e) {\n    var _props4 = _this2.props,\n        closeOnNavItemClick = _props4.closeOnNavItemClick,\n        autoclose = _props4.autoclose,\n        autocloseAfterInk = _props4.autocloseAfterInk;\n\n    var enabled = typeof closeOnNavItemClick !== 'undefined' ? closeOnNavItemClick : autoclose;\n    if (!enabled || !isTemporary(getField(_this2.props, _this2.state, 'type'))) {\n      return;\n    }\n\n    var target = e.target;\n\n    while (target && _this2._navigation.contains(target)) {\n      if (target.classList.contains('md-list-tile')) {\n        // Clicked a nav item that has a nested list\n        if (target.getAttribute('aria-expanded') !== null) {\n          return;\n        }\n\n        _this2._closeTimeout = setTimeout(function () {\n          _this2._closeTimeout = null;\n\n          _this2._closeDrawer(e);\n        }, autocloseAfterInk ? 300 : TICK);\n        return;\n      }\n\n      target = target.parentNode;\n    }\n  };\n\n  this._closeDrawer = function () {\n    var _props5 = _this2.props,\n        onVisibilityChange = _props5.onVisibilityChange,\n        onVisibilityToggle = _props5.onVisibilityToggle,\n        transitionDuration = _props5.transitionDuration,\n        overlay = _props5.overlay;\n\n    var callback = onVisibilityToggle || onVisibilityChange;\n    if (callback) {\n      callback(false);\n    }\n\n    if (typeof _this2.props.visible === 'undefined') {\n      _this2.setState({ visible: false });\n      _this2._animate(false, getField(_this2.props, _this2.state, 'type'), transitionDuration, overlay, _this2.state.desktop);\n    }\n  };\n};\n\nexport default Drawer;"]},"metadata":{},"sourceType":"module"}