{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport { findDOMNode } from 'react-dom';\nimport isValidFocusKeypress from '../utils/EventUtils/isValidFocusKeypress';\nvar BASE_FOCUSABLE_ELEMENTS = '[href],[tabindex]:not([tabindex=\"-1\"]),input:not([disabled]):not([type=\"hidden\"])';\nvar FOCUSABLE_QUERY = ['button', 'textarea', 'select'].reduce(function (queryString, element) {\n  return queryString + ',' + element + ':not([disabled])';\n}, BASE_FOCUSABLE_ELEMENTS);\n/**\n * This component is used for keeping the focus within some container. When the container\n * is mounted and the `focusOnMount` prop is `true`, it will attempt to focus either:\n * - an element that matches `document.getElementById(this.props.initialFocus)`\n * - an element that matches `this._container.querySelector(this.props.initialFocus)`\n * - the first focusable element in it's children (if `this.props.initialFocus` is omitted)\n */\n\nvar FocusContainer = function (_PureComponent) {\n  _inherits(FocusContainer, _PureComponent);\n\n  function FocusContainer() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, FocusContainer);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._enableFocusTrap = function () {\n      window.addEventListener('keydown', _this._handleKeyDown, true);\n    }, _this._disableFocusTrap = function () {\n      window.removeEventListener('keydown', _this._handleKeyDown, true);\n    }, _this._attemptInitialFocus = function () {\n      if (!_this._container) {\n        return;\n      }\n\n      var initialFocus = _this.props.initialFocus;\n      var toFocus = initialFocus ? document.getElementById(initialFocus) || _this._container.querySelector(initialFocus) : _this._focusables[0];\n      var debugError = void 0;\n\n      if (!toFocus && initialFocus) {\n        debugError = ' The `initialFocus` did not match a document\\'s `id` or was an invalid ';\n        debugError += '`querySelector` for the container. `initialFocus`: `' + initialFocus + '`. ';\n        debugError += 'If this was supposed to be an `id`, make sure to prefix with the `#` symbol.';\n      }\n\n      if (process.env.NODE_ENV !== 'production' && !toFocus) {\n        throw new Error('You specified that the `FocusContainer` should focus an element on mount, ' + 'but a focusable element was not found in the children. This could be because ' + 'the `initialFocus` prop is an invalid id or query selector, or the children ' + ('do not contain a valid focusable element.' + debugError));\n      }\n\n      if (toFocus) {\n        toFocus.focus();\n      }\n    }, _this._containFocus = function (containerRef) {\n      if (containerRef === null) {\n        _this._container = null;\n\n        _this._disableFocusTrap();\n\n        return;\n      }\n\n      var _this$props = _this.props,\n          focusOnMount = _this$props.focusOnMount,\n          containFocus = _this$props.containFocus;\n      _this._container = findDOMNode(containerRef);\n      _this._focusables = [].slice.call(_this._container.querySelectorAll(FOCUSABLE_QUERY));\n\n      if (focusOnMount) {\n        _this._attemptInitialFocus();\n      }\n\n      if (containFocus) {\n        _this._enableFocusTrap();\n      }\n    }, _this._handleKeyDown = function (e) {\n      _this._shifted = e.shiftKey;\n\n      if (!isValidFocusKeypress(e, _this.props.additionalFocusKeys)) {\n        return;\n      } else if (_this._focusables.length === 1) {\n        e.preventDefault();\n        return;\n      }\n\n      var target = e.target,\n          shiftKey = e.shiftKey;\n\n      var _this$_focusables = _this._focusables,\n          first = _this$_focusables[0],\n          focusables = _this$_focusables.slice(1);\n\n      var last = focusables[focusables.length - 1];\n\n      if (shiftKey && target === first) {\n        e.preventDefault();\n        last.focus();\n      } else if (!shiftKey && target === last) {\n        e.preventDefault();\n        first.focus();\n      }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  FocusContainer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (this.props.containFocus === nextProps.containFocus) {\n      return;\n    }\n\n    if (nextProps.containFocus) {\n      this._enableFocusTrap();\n\n      this._attemptInitialFocus();\n    } else {\n      this._disableFocusTrap();\n    }\n  };\n\n  FocusContainer.prototype.componentDidUpdate = function componentDidUpdate() {\n    if (this.props.containFocus && this._container) {\n      this._focusables = [].slice.call(this._container.querySelectorAll(FOCUSABLE_QUERY));\n    }\n  };\n\n  FocusContainer.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this.props.containFocus) {\n      this._disableFocusTrap();\n    }\n  };\n  /**\n   * Manages the event listeners to contain the focus within some container.  When the container\n   * ref is not null, the container has mounted and then attempts to focus an element inside\n   * if the `focusOnMount` prop is `true`.\n   */\n\n\n  FocusContainer.prototype.render = function render() {\n    var _props = this.props,\n        Component = _props.component,\n        initialFocus = _props.initialFocus,\n        focusOnMount = _props.focusOnMount,\n        containFocus = _props.containFocus,\n        additionalFocusKeys = _props.additionalFocusKeys,\n        props = _objectWithoutProperties(_props, ['component', 'initialFocus', 'focusOnMount', 'containFocus', 'additionalFocusKeys']);\n\n    return React.createElement(Component, _extends({}, props, {\n      ref: this._containFocus\n    }));\n  };\n\n  return FocusContainer;\n}(PureComponent);\n\nFocusContainer.propTypes = {\n  /**\n   * The component to render as. This can be a React DOM element or\n   * a react Component.\n   */\n  component: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]).isRequired,\n\n  /**\n   * An optional style to apply.\n   */\n  style: PropTypes.object,\n\n  /**\n   * An optional className to apply.\n   */\n  className: PropTypes.string,\n\n  /**\n   * The children to display.\n   */\n  children: PropTypes.node,\n\n  /**\n   * An optional id string or a query selector string to use for the initial focus.\n   * This will only be triggered if the `focusOnMount` prop is `true`. If this is\n   * omitted and the `focusOnMount` prop is `true`, the first focusable element in the\n   * container will be focused.\n   *\n   * Examples:\n   *\n   * ```js\n   * initialFocus=\"#someAmazingId\"\n   * // or\n   * initialFocus=\".md-btn,.md-list-tile\"\n   * ```\n   */\n  initialFocus: PropTypes.string,\n\n  /**\n   * Boolean if an element in the container should be focused when mounted.\n   */\n  focusOnMount: PropTypes.bool,\n\n  /**\n   * An optional list of additional key codes to use for focus events.\n   */\n  additionalFocusKeys: PropTypes.arrayOf(PropTypes.number),\n\n  /**\n   * Boolean if the focus container should start or stop containing the focus within the container.\n   * This is useful for changing the focus requirements after mount.\n   */\n  containFocus: PropTypes.bool\n};\nFocusContainer.defaultProps = {\n  component: 'div',\n  containFocus: true\n};\nexport default FocusContainer;","map":{"version":3,"sources":["C:/Users/Sky/Desktop/info442/homeowork/node_modules/react-md/es/Helpers/FocusContainer.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_objectWithoutProperties","obj","keys","indexOf","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","React","PureComponent","PropTypes","findDOMNode","isValidFocusKeypress","BASE_FOCUSABLE_ELEMENTS","FOCUSABLE_QUERY","reduce","queryString","element","FocusContainer","_PureComponent","_temp","_this","_ret","_len","args","Array","_key","apply","concat","_enableFocusTrap","window","addEventListener","_handleKeyDown","_disableFocusTrap","removeEventListener","_attemptInitialFocus","_container","initialFocus","props","toFocus","document","getElementById","querySelector","_focusables","debugError","process","env","NODE_ENV","Error","focus","_containFocus","containerRef","_this$props","focusOnMount","containFocus","slice","querySelectorAll","e","_shifted","shiftKey","additionalFocusKeys","preventDefault","_this$_focusables","first","focusables","last","componentWillReceiveProps","nextProps","componentDidUpdate","componentWillUnmount","render","_props","Component","component","createElement","ref","propTypes","oneOfType","string","func","object","isRequired","style","className","children","node","bool","arrayOf","number","defaultProps"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport { findDOMNode } from 'react-dom';\n\nimport isValidFocusKeypress from '../utils/EventUtils/isValidFocusKeypress';\n\nvar BASE_FOCUSABLE_ELEMENTS = '[href],[tabindex]:not([tabindex=\"-1\"]),input:not([disabled]):not([type=\"hidden\"])';\nvar FOCUSABLE_QUERY = ['button', 'textarea', 'select'].reduce(function (queryString, element) {\n  return queryString + ',' + element + ':not([disabled])';\n}, BASE_FOCUSABLE_ELEMENTS);\n\n/**\n * This component is used for keeping the focus within some container. When the container\n * is mounted and the `focusOnMount` prop is `true`, it will attempt to focus either:\n * - an element that matches `document.getElementById(this.props.initialFocus)`\n * - an element that matches `this._container.querySelector(this.props.initialFocus)`\n * - the first focusable element in it's children (if `this.props.initialFocus` is omitted)\n */\n\nvar FocusContainer = function (_PureComponent) {\n  _inherits(FocusContainer, _PureComponent);\n\n  function FocusContainer() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, FocusContainer);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._enableFocusTrap = function () {\n      window.addEventListener('keydown', _this._handleKeyDown, true);\n    }, _this._disableFocusTrap = function () {\n      window.removeEventListener('keydown', _this._handleKeyDown, true);\n    }, _this._attemptInitialFocus = function () {\n      if (!_this._container) {\n        return;\n      }\n\n      var initialFocus = _this.props.initialFocus;\n\n\n      var toFocus = initialFocus ? document.getElementById(initialFocus) || _this._container.querySelector(initialFocus) : _this._focusables[0];\n\n      var debugError = void 0;\n      if (!toFocus && initialFocus) {\n        debugError = ' The `initialFocus` did not match a document\\'s `id` or was an invalid ';\n        debugError += '`querySelector` for the container. `initialFocus`: `' + initialFocus + '`. ';\n        debugError += 'If this was supposed to be an `id`, make sure to prefix with the `#` symbol.';\n      }\n\n      if (process.env.NODE_ENV !== 'production' && !toFocus) {\n        throw new Error('You specified that the `FocusContainer` should focus an element on mount, ' + 'but a focusable element was not found in the children. This could be because ' + 'the `initialFocus` prop is an invalid id or query selector, or the children ' + ('do not contain a valid focusable element.' + debugError));\n      }\n\n      if (toFocus) {\n        toFocus.focus();\n      }\n    }, _this._containFocus = function (containerRef) {\n      if (containerRef === null) {\n        _this._container = null;\n        _this._disableFocusTrap();\n        return;\n      }\n\n      var _this$props = _this.props,\n          focusOnMount = _this$props.focusOnMount,\n          containFocus = _this$props.containFocus;\n\n      _this._container = findDOMNode(containerRef);\n      _this._focusables = [].slice.call(_this._container.querySelectorAll(FOCUSABLE_QUERY));\n\n      if (focusOnMount) {\n        _this._attemptInitialFocus();\n      }\n\n      if (containFocus) {\n        _this._enableFocusTrap();\n      }\n    }, _this._handleKeyDown = function (e) {\n      _this._shifted = e.shiftKey;\n      if (!isValidFocusKeypress(e, _this.props.additionalFocusKeys)) {\n        return;\n      } else if (_this._focusables.length === 1) {\n        e.preventDefault();\n        return;\n      }\n\n      var target = e.target,\n          shiftKey = e.shiftKey;\n\n      var _this$_focusables = _this._focusables,\n          first = _this$_focusables[0],\n          focusables = _this$_focusables.slice(1);\n\n      var last = focusables[focusables.length - 1];\n\n      if (shiftKey && target === first) {\n        e.preventDefault();\n        last.focus();\n      } else if (!shiftKey && target === last) {\n        e.preventDefault();\n        first.focus();\n      }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  FocusContainer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (this.props.containFocus === nextProps.containFocus) {\n      return;\n    }\n\n    if (nextProps.containFocus) {\n      this._enableFocusTrap();\n      this._attemptInitialFocus();\n    } else {\n      this._disableFocusTrap();\n    }\n  };\n\n  FocusContainer.prototype.componentDidUpdate = function componentDidUpdate() {\n    if (this.props.containFocus && this._container) {\n      this._focusables = [].slice.call(this._container.querySelectorAll(FOCUSABLE_QUERY));\n    }\n  };\n\n  FocusContainer.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this.props.containFocus) {\n      this._disableFocusTrap();\n    }\n  };\n\n  /**\n   * Manages the event listeners to contain the focus within some container.  When the container\n   * ref is not null, the container has mounted and then attempts to focus an element inside\n   * if the `focusOnMount` prop is `true`.\n   */\n\n\n  FocusContainer.prototype.render = function render() {\n    var _props = this.props,\n        Component = _props.component,\n        initialFocus = _props.initialFocus,\n        focusOnMount = _props.focusOnMount,\n        containFocus = _props.containFocus,\n        additionalFocusKeys = _props.additionalFocusKeys,\n        props = _objectWithoutProperties(_props, ['component', 'initialFocus', 'focusOnMount', 'containFocus', 'additionalFocusKeys']);\n\n    return React.createElement(Component, _extends({}, props, { ref: this._containFocus }));\n  };\n\n  return FocusContainer;\n}(PureComponent);\n\nFocusContainer.propTypes = {\n  /**\n   * The component to render as. This can be a React DOM element or\n   * a react Component.\n   */\n  component: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]).isRequired,\n\n  /**\n   * An optional style to apply.\n   */\n  style: PropTypes.object,\n\n  /**\n   * An optional className to apply.\n   */\n  className: PropTypes.string,\n\n  /**\n   * The children to display.\n   */\n  children: PropTypes.node,\n\n  /**\n   * An optional id string or a query selector string to use for the initial focus.\n   * This will only be triggered if the `focusOnMount` prop is `true`. If this is\n   * omitted and the `focusOnMount` prop is `true`, the first focusable element in the\n   * container will be focused.\n   *\n   * Examples:\n   *\n   * ```js\n   * initialFocus=\"#someAmazingId\"\n   * // or\n   * initialFocus=\".md-btn,.md-list-tile\"\n   * ```\n   */\n  initialFocus: PropTypes.string,\n\n  /**\n   * Boolean if an element in the container should be focused when mounted.\n   */\n  focusOnMount: PropTypes.bool,\n\n  /**\n   * An optional list of additional key codes to use for focus events.\n   */\n  additionalFocusKeys: PropTypes.arrayOf(PropTypes.number),\n\n  /**\n   * Boolean if the focus container should start or stop containing the focus within the container.\n   * This is useful for changing the focus requirements after mount.\n   */\n  containFocus: PropTypes.bool\n};\nFocusContainer.defaultProps = {\n  component: 'div',\n  containFocus: true\n};\nexport default FocusContainer;"]},"metadata":{},"sourceType":"module"}